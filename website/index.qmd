---
title: "Tracking the Intangible: Quantifying Effort in NFL Running Backs"
author:
- "Emily Shteynberg"
- "Luke Snavely"
- "Sheryl Solorzano"
date: "July 25, 2025"
format:
  html:
    html-math-method: katex
    self-contained: true
execute:
  echo: false
  warning: false
  message: false
bibliography: bib/library.bib
---

```{r}
#| label: setup
#| include: false

# Load necessary packages
library(tidyverse)
library(knitr)
library(ggplot2)
library(plotly)
library(tidytext)
library(quantreg)
library(qgam)
library(knitr)
library(kableExtra)
library(gridExtra)
library(patchwork)
library(gt)
library(gtExtras)
```


---

## Introduction 

While athletes are often praised for “giving 100%,” what that entails remains poorly defined and difficult to measure objectively. Unlike physical traits such as endurance, strength, and agility, effort is intangible and often conflated with performance outcomes or inferred through subjective observation. Nevertheless, it is widely regarded as a crucial factor in athletic success, influencing both perceived competitiveness and in-game results. Developing a reliable, standardized method to evaluate effort could offer new insight into player capabilities and decision-making.

This study focuses on running backs (RBs) in the NFL, a position characterized by short, high-intensity bursts of movement within clearly structured offensive plays. The nature of their role—frequent accelerations and heavy physical contact—makes RBs a suitable candidate for analyzing exertion in a relatively controlled and consistent context.

Our approach builds on prior work deriving professional soccer players’ theoretical maximum acceleration capacity as a function of running speed in-situ.^1^ To date, no comparable methodology has been applied to American football. By adapting it to RBs, we aim to isolate the measurable, movement-based component of effort, independent of tactical decisions or situational context.

The objective of this study is twofold: (1) to improve estimation of individual acceleration-speed (A-S) profiles using tracking data, and (2) to assess how frequently players operate near or exceed these limits as a proxy for effort.


## Data

The data were obtained from the NFL Big Data Bowl 2025, an annual league-sponsored analytics competition that provides game, play, player, and tracking data recorded at 10 frames per second.^2^ The dataset covers weeks 1-9 of the 2022 NFL season, comprising 136 games.

### Pre-processing: 

* Using the tracking data, we first standardized players’ positional coordinates and orientations such that all plays move from left to right, with the bottom-left corner of the field set as the “origin.”

* After merging the data, we filtered for running plays where the RB was the ball carrier and restricted the sample to RBs with at least 20 rushing attempts, yielding 69 players. Each observation corresponds to a single frame of tracking data.


### Feature engineering:

* The tracking data provided only the magnitudes of velocity (speed) and acceleration. To be able to distinguish between positive acceleration and negative acceleration (deceleration), we first derived the x- and y-components of velocity by multiplying the given speed by the sine and cosine of the angle of player motion, respectively. Next, we computed the x- and y-components of acceleration by calculating the frame-to-frame change in the corresponding components of velocity over the 0.1 second time interval. Finally, we constructed a variable for *directional* acceleration by dividing the dot product of the velocity and acceleration vectors by the magnitude of velocity. 

* We converted speed and directional acceleration to miles per hour (mph) and miles per hour per second (mph/s), respectively.

* We created several frame-level variables, all measured at the time of handoff, for use in our validation model *(see Methods)* as follows:

  * **Distance to nearest defender**: compute the Euclidean distance between the RB’s and each defender’s positional coordinates; select the minimum distance 

  * **Number of defenders within 5 yards of the RB**: count the number of defenders whose Euclidean distance to the RB is less than or equal to 5 yards 

  * **Number of blockers in front of the RB**: the number of blockers (defined as offensive linemen or fullbacks) whose x-coordinates exceed that of the RBs

```{r}
#| label: data-table
#| message: false
#| warning: false
#| cache: true
load("web_data/tracking_bc3.Rdata")

tracking_bc |> 
  select(gameId, playId, bc_id, displayName, frameId, event, x, y, s_mph, dir_a_right_mpsh) |> 
  mutate(s_mph = round(s_mph, 2),
         dir_a_right_mpsh = round(dir_a_right_mpsh, 2)) |> 
  filter(displayName == "Christian McCaffrey") |> 
  slice_head(n = 5) |> 
  gt() |> 
  tab_header(title = md("**Cleaned tracking data**")) |>
  cols_label(gameId = "Game", playId = "Play", bc_id = "Ball Carrier", displayName = "Name",
             fameId = "Frame", event = "Event", x = "X Coordinate", y = "Y Coordinate", s_mph = "Speed (mph)", 
             dir_a_right_mpsh = "Directional Acceleration (mph/s)") |> 
  gtExtras::gt_theme_espn() |> 
  cols_align(align = "left")
```


## Methods

### Motivation

Our initial approach was adapted from the aforementioned prior research building individual A-S profiles of soccer players.^1^ For each RB, we plot the frame-level A-S profile based on the maximal acceleration they could generate for every possible running speed using the *Morin et al., 2021* procedure as follows:


Within a speed interval ranging between 3 mph and the RB’s maximal speed, the two maximal acceleration values attained for each 0.2 mph subinterval were selected. A first linear regression was fitted to these speed-acceleration points. Outlier points lying outside of the 95% confidence interval around the linear function were removed. A final linear regression was fitted to the remaining points, defining what we refer to as the “maximum acceleration frontier.”

> <span style="color: black; font-style: normal;">
> To compute “effort” from the A-S profile, the regression line was first shifted downward by 0.25 units (determined via sensitivity analysis) to include points sufficiently close to the estimated frontier. Effort was then defined as the percentage of a player’s points that fell above this relaxed threshold.
> </span>


```{r}
#| label: original-plot
#| message: false
#| warning: false
#| cache: true


load("web_data/tracking_bc2.Rdata")
load("web_data/player_runs_modeling.Rdata")


eff_function <- function(name, graph = FALSE, player_table = FALSE, regress = FALSE) {
  # Filter for player
  player_runs <- tracking_bc |> filter(displayName == name)
  
  # Bin by speed
  bins <- seq(3, round(max(player_runs$s_mph), 2) + .2, .2)
  max_acc <- map_dfr(1:(length(bins) - 1), function(i) {
    player_runs |> 
      filter(s_mph > bins[i], s_mph <= bins[i + 1]) |> 
      slice_max(a_mpsh, n = 2, with_ties = FALSE) |> 
      select(speed = s_mph, acceleration = a_mpsh)
  })
  
  # First regression
  player_lm <- lm(acceleration ~ speed, data = max_acc)
  confs <- predict(player_lm, interval = "confidence")
  max_acc <- bind_cols(max_acc, confs)
  
  # Remove outliers and refit
  max_acc_clean <- max_acc |> filter(acceleration >= lwr, acceleration <= upr)
  player_lm_clean <- lm(acceleration ~ speed, data = max_acc_clean)
  
  # Predict acceleration for full data
  test_player_a <- data.frame(speed = player_runs$s_mph, acceleration = player_runs$a_mpsh)
  test_preds <- predict(player_lm_clean, newdata = test_player_a)
  
  player_final <- player_runs |> 
    select(a_mpsh, s_mph) |> 
    mutate(pred = test_preds,
           diff = pred - a_mpsh,
           eff = diff <= 0.25,
           eff_50 = diff <= 0.5,
           eff_75 = diff <= 0.75,
           gameId = player_runs$gameId,
           playId = player_runs$playId,
           bc_id = player_runs$bc_id,
           displayName = player_runs$displayName,
           frameId = player_runs$frameId)
  
  eff <- tibble(
    eff_metric = sum(player_final$eff, na.rm = TRUE),
    eff_metric_perc = sum(player_final$eff, na.rm = TRUE) / nrow(player_final) * 100,
    eff_metric_50 = sum(player_final$eff_50, na.rm = TRUE),
    eff_metric_perc_50 = sum(player_final$eff_50, na.rm = TRUE) / nrow(player_final) * 100,
    eff_metric_75 = sum(player_final$eff_75, na.rm = TRUE),
    eff_metric_perc_75 = sum(player_final$eff_75, na.rm = TRUE) / nrow(player_final) * 100
  )
  
  if (graph == TRUE) {
    # Compute regression line
    intercept <- player_lm_clean$coefficients[1]
    slope <- player_lm_clean$coefficients[2]
    s_seq <- seq(min(player_runs$s_mph), max(player_runs$s_mph), length.out = 200)
    
    reg_line <- tibble(
      speed = s_seq,
      reg = intercept + slope * s_seq
    )
    
    # Compute max Y for shading
    y_max <- max(player_runs$a_mpsh, na.rm = TRUE)

    # Build plotly plot
    p <- plot_ly() |>
      # Player data
      add_markers(
        data = player_runs,
        x = ~s_mph,
        y = ~a_mpsh,
        text = ~paste0("Speed: ", round(s_mph, 2), " mph<br>Accel: ", round(a_mpsh, 2), " m/s²"),
        hoverinfo = "text",
        marker = list(color = "black", size = 6, opacity = 0.6),
        name = "Frames"
      ) |>
      
      # Top acceleration points (filled circles w/ black stroke)
      add_markers(
        data = max_acc_clean,
        x = ~speed,
        y = ~acceleration,
        type = "scatter",
        mode = "markers",
        marker = list(size = 10, color = "#b3b3b3", line = list(width = 2, color = "black")),
        name = "Top Accel Points"
      ) |>
      
      # Regression line
      add_trace(
        data = reg_line,
        x = ~speed,
        y = ~reg,
        type = "scatter",
        mode = "lines",
        line = list(color = "#0072B2", width = 2.5),
        name = "Regression Line"
      ) |>
      
      # Layout and shaded region
      layout(
        shapes = list(
          list(
            type = "rect",
            x0 = 0,
            x1 = 3,
            y0 = 0,
            y1 = y_max,
            fillcolor = "#e7e7e7",
            line = list(width = 0),
            opacity = 0.04,
            layer = "below"
          )
        ),
        title = list(
          text = paste0(
            "We consider points close to and above a player’s<br>",
            "<i>maximum acceleration frontier</i> effortful",
            "<br><sub><span style='font-size:14px;'>Acceleration-Speed (A-S) profile for ", name, "</span></sub>"
          ),
          font = list(size = 18),
          x = 0.5,
          xanchor = "center"
        ),
        xaxis = list(title = "Speed (mph)", titlefont = list(size = 14)),
        yaxis = list(title = "Magnitude of acceleration (mph/s)", titlefont = list(size = 14)),
        showlegend = FALSE,
        hoverlabel = list(font = list(size = 13)),
        margin = list(l = 70, r = 130, b = 60, t = 100),
        showlegend = TRUE
      )

    return(p)
  }
  
  if (player_table == TRUE) return(player_final)
  
  if (regress == TRUE) {
    return(tibble(
      displayName = name,
      A_0 = player_lm_clean$coefficients[1],
      S_0 = (-player_lm_clean$coefficients[1]) / player_lm_clean$coefficients[2]
    ))
  }
  
  return(eff)
}

# TEST
eff_function("Christian McCaffrey", graph = TRUE)

```



However, this approach has several limitations. First, it excludes points with speeds below 3 mph from the linear regression model, effectively disregarding low-speed frames—even though effort may still be exerted at lower velocities. Second, the model extrapolates beyond the observed data, leading to unrealistic estimates of theoretical maximum speeds. Third, players with greater athletic ability may be disproportionately penalized. Because the frontier is estimated relative to each player’s own maximal accelerations, players with a greater physical capacity must reach a higher threshold for their frames to be classified as effortful. Finally, the model does not differentiate between acceleration and deceleration; all changes in velocity are treated equally, despite our belief that deceleration requires less effort than acceleration, as it typically demands less metabolic power.^3^

::: {.panel-tabset}
### Theoretical Max Acceleration (A~0~)

![](photos/A_0_graph.png){width=80%}

### Theoretical Max Speed (S~0~)

![](photos/S_0_graph.png){width=80%}
:::

### Metric #1: Quadratic Quantile Regression

To address the shortcomings of the linear regression approach, we developed an effort metric based on quadratic quantile regression. This method was selected for two reasons. First, the relationship between acceleration and speed is empirically nonlinear. Second, quantile regression enables an estimation of the upper envelope of a player’s acceleration distribution. Unlike ordinary least squares techniques (e.g., linear regression), which estimate the conditional mean, quantile regression is more appropriate for identifying players’ maximum acceleration capacities. Specifically, the 0.95 quantile (i.e., the 95th percentile) was used to represent each player’s maximum acceleration frontier, capturing some of their highest observed exertions while minimizing the impact of outliers. For example, extreme, one-off accelerations in the 0.99 quantile might distort the frontier.

For every RB, we again examine the joint distribution of frame-level speed and acceleration. We fit two quadratic quantile regressions to estimate the 0.95 quantiles of acceleration and deceleration, respectively, as functions of speed. Each model was trained on all available frames for a given player. The resulting curves define the individual maximum acceleration frontiers: one for acceleration and another for deceleration.  

We compute effort as follows: first, calculate the vertical distance $d_i$ from each point to the frontier corresponding to its acceleration sign, setting $d_i=0$ for points on or past the curve. Each frame is assigned a score according to 

$$
\Psi_i = \begin{cases}
  \frac{1}{1+d_i} & a_i\geq 0 \\
  \frac{1}{2}\cdot\frac{1}{1+d_i} & a_i<0,
    \end{cases}
$$
where $a_i$ denotes the point’s acceleration.

Points with negative acceleration are penalized by a factor of 0.5, reflecting prior findings that deceleration is 2-4 times less metabolically demanding than acceleration.^3^ We thus consider deceleration less effortful. 

Finally, average effort for each player is computed as the mean of their frame-level scores:

$$
\text{Effort} = \frac{\sum_{i=1}^n \Psi}{n}
$$



```{r}
#| label: plot-ly
#| message: false
#| warning: false
#| cache: true


load("web_data/tracking_bc3.Rdata")
load("web_data/player_runs_modeling.Rdata")

eff_function_qgam <- function(name, graph = FALSE) {
  player_runs <- tracking_bc |> 
    filter(displayName == name)

  player_runs_modeling <- player_runs |> 
    select(s_mph, dir_a_mpsh = dir_a_right_mpsh, gameId, displayName, bc_id, playId, frameId)

  data_pos <- player_runs_modeling |> filter(dir_a_mpsh >= 0)
  data_neg <- player_runs_modeling |> filter(dir_a_mpsh < 0)

  nlrq_pos <- nlrq(dir_a_mpsh ~ x * s_mph^2 + y * s_mph + z,
                   data = data_pos,
                   tau = .95,
                   start = list(x = 10, y = 2, z = 5))
  
  nlrq_neg <- nlrq(dir_a_mpsh ~ x * s_mph^2 + y * s_mph + z,
                   data = data_neg,
                   tau = .05,
                   start = list(x = 10, y = 2, z = 5))

  data_pos_final <- data_pos |> 
    mutate(nlrq_pred = nlrq_pos$m$fitted(),
           diff_a = nlrq_pred - dir_a_mpsh)

  data_neg_final <- data_neg |> 
    mutate(nlrq_pred = nlrq_neg$m$fitted(),
           diff_a = dir_a_mpsh - nlrq_pred)

  player_runs_test_preds <- rbind(data_pos_final, data_neg_final)

  if (graph == TRUE) {
    out_line <- player_runs_test_preds |> filter(diff_a <= 0)

    # Build ggplot with text column for tooltips
    p <- ggplot(player_runs_test_preds, aes(x = s_mph, y = dir_a_mpsh)) +
      geom_point(aes(text = paste0("Speed: ", round(s_mph, 2),
                                   "<br>Acceleration: ", round(dir_a_mpsh, 2))),
                 alpha = 0.6, color = "grey2", show.legend = FALSE) +
      geom_point(data = out_line, aes(
        text = paste0("Speed: ", round(s_mph, 2),
                      "<br>Acceleration: ", round(dir_a_mpsh, 2))),
        size = 4, stroke = 1.2, color = "black", shape = 21, fill = "#b3b3b3") +
      geom_line(data = data_pos_final, aes(y = nlrq_pred, color = "0.95 quantile accel. \nregression line"), lwd = 1.2) +
      geom_line(data = data_neg_final, aes(y = nlrq_pred, color = "0.95 quantile decel. \nregression line"), lwd = 1.2) +
      geom_hline(aes(yintercept = 0), color = "black", lwd = 1.2, lty = 2) +
      scale_color_manual("Line", values = c("#D50A0A", "#0072B2", "goldenrod")) +
      labs(x = "Speed (mph)",
           y = "Acceleration (mph/s)",
           title = paste0(name, "'s effort Quantile (95%")) +
      theme_minimal(base_size=16) +
      theme(plot.title = element_text(face = "bold.italic", size = 18, hjust = .5),
            legend.title = element_text(face = "bold"),
            axis.title = element_text(face = "bold"),
            legend.text=element_text(size=15),
            plot.caption = element_text(face = "italic", size = 8),
            legend.key.height = unit(1.4, "cm"),
            legend.position = "right") +
      xlim(0, 25) +
      ylim(-15, 15)

    return(ggplotly(p, tooltip = "text"))
  }

  return(player_runs_test_preds)
}

# testing player
#eff_function_qgam("Saquon Barkley", graph = TRUE)


#Player list (in progress)
rb_menu <- c("Saquon Barkley", "Rex Burkhead", "D'Andre Swift",
                "Samaje Perine", "Joshua Kelley", "Matt Breida", "Alexander Mattison")

# Initialize plot
fig1 <- plot_ly()
all_traces <- list()
visibility_masks <- list()
trace_lengths <- c()

#Loop through each running back to collect their traces
for (i in seq_along(rb_menu)) {
  player <- rb_menu[i]
  plot_obj <- ggplotly(eff_function_qgam(player, graph = TRUE))

  player_traces <- list()
  for (trace in plot_obj$x$data) {
    if (trace$mode == "markers") {
    }
    trace$visible <- (i == 1)

    # this is to display the first running back's AS quantile regression
    fig1 <- fig1 |> add_trace(
      x = trace$x,
      y = trace$y,
      type = trace$type,
      mode = trace$mode,
      line = trace$line,
      marker = if (!is.null(trace$marker$color)) trace$marker else NULL,
      name = trace$name,
      text = trace$text,
      hoverinfo = trace$hoverinfo,
      visible = trace$visible
    )
    player_traces <- append(player_traces, list(trace))
  }

  all_traces[[i]] <- player_traces
  trace_lengths[i] <- length(player_traces)
}

#  Visibility masks for dropdown
total_traces <- sum(trace_lengths)

for (i in seq_along(rb_menu)) {
  mask <- rep(FALSE, total_traces)
  start_index <- sum(trace_lengths[1:(i - 1)]) + 1
  end_index <- sum(trace_lengths[1:i])
  mask[start_index:end_index] <- TRUE
  visibility_masks[[i]] <- mask
}

# Adding dropdown menu
dropdown_buttons <- lapply(seq_along(rb_menu), function(i) {
  list(
    method = "update",  # update both trace visibility and layout
    args = list(
      list(visible = visibility_masks[[i]]),  # traces to show
      list(title = list(text = paste0(rb_menu[i], "'s Effort Quantile (95%)")))  # title change
    ),
    label = rb_menu[i]
  )
})

fig1 <- fig1 |>
  layout(
    title = list(text = paste0(rb_menu[1], "'s Effort Quantile (95%)")),
    yaxis = list(title = "Acceleration (mph/s)"),
    xaxis = list(title = "Speed (mph)"),
    updatemenus = list(
      list(
        type = "dropdown",
        y = 0.6,
        x = 1.3,
        buttons = dropdown_buttons
      )
    )
  )
fig1
```





### Metric #2: Quantile Generalized Additive Model (QGAM)

As an alternative to the fixed-form quadratic quantile regression, we implemented a QGAM to allow greater flexibility in estimating the individual maximum acceleration frontier. A GAM is particularly well-suited to our context, as the true A-S profile may vary in form across players and is unlikely to consistently follow a simple quadratic curve. We continued to use the 0.95 quantile to capture near-maximal acceleration while mitigating sensitivity to outliers.

For each RB, we fit two QGAMs with adaptive spline bases to the 0.95 quantiles of acceleration and deceleration, respectively, as functions of speed. The resulting curves again define the individualized frontiers for acceleration and deceleration. Average frame-level effort is then computed according to the same procedure as for Metric #1 above.


   

```{r}
#| label: effort-metric-one
#| fig-cap: "......"
#| message: false
#| warning: false
#| cache: true

load("web_data/tracking_bc3.Rdata")
load("web_data/player_runs_modeling.Rdata")
load("web_data/rbs_names.Rdata")

# qgam right --------------------------------------------------------------

eff_function_qgam <- function(name, graph = FALSE) {
  # Choosing player name
  player_runs <- tracking_bc |> 
    filter(displayName == name)
  
  # Modeling dataframe
  player_runs_modeling <- player_runs |> 
    select(s_mph, dir_a_mpsh = dir_a_right_mpsh, gameId, displayName, bc_id, playId, frameId)
  
  # Split positive and negative acceleration
  data_pos <- player_runs_modeling |> filter(dir_a_mpsh >= 0)
  data_neg <- player_runs_modeling |> filter(dir_a_mpsh < 0)

  # Fit qgam models
  suppressMessages({
    suppressWarnings({
      capture.output({
        qgam_fit_a_top <- qgam(dir_a_mpsh ~ s(s_mph, k = 10, bs = "ad"),
                               data = data_pos, qu = .95,
                               multicore = TRUE, ncores = 7)
      })
    })
  })

  suppressMessages({
    suppressWarnings({
      capture.output({
        qgam_fit_a_bottom <- qgam(dir_a_mpsh ~ s(s_mph, k = 10, bs = "ad"),
                                  data = data_neg, qu = .05,
                                  multicore = TRUE, ncores = 7)
      })
    })
  })

  # Add predicted values
  data_pos_final <- data_pos |> 
    mutate(qgam_pred = qgam_fit_a_top$fitted.values,
           diff_a = qgam_pred - dir_a_mpsh)

  data_neg_final <- data_neg |> 
    mutate(qgam_pred = qgam_fit_a_bottom$fitted.values,
           diff_a = dir_a_mpsh - qgam_pred)

  # Combine
  player_runs_test_preds <- bind_rows(data_pos_final, data_neg_final)

  if (graph == TRUE) {
    out_line <- player_runs_test_preds |> filter(diff_a <= 0)

    # Base ggplot with custom tooltip
    p <- ggplot(player_runs_test_preds, aes(x = s_mph, y = dir_a_mpsh)) +
      geom_point(aes(
        text = paste0("Speed: ", round(s_mph, 2),
                      "<br>Acceleration: ", round(dir_a_mpsh, 2))),
        alpha = 0.6, color = "grey2") +
      geom_point(data = out_line, aes(
        text = paste0("Speed: ", round(s_mph, 2),
                      "<br>Acceleration: ", round(dir_a_mpsh, 2))),
        fill = "#b3b3b3", color = "black", stroke = 1.2, shape = 21, size = 4) +
      geom_line(data = data_pos_final, aes(y = qgam_pred, color = "0.95 quantile accel. \nregression line"), lwd = 1.2) +
      geom_line(data = data_neg_final, aes(y = qgam_pred, color = "0.95 quantile decel. \nregression line"), lwd = 1.2) +
      geom_hline(aes(yintercept = 0), color = "black", lwd = 1.2, lty = 2) +
      scale_color_manual("Line", values = c("#D50A0A", "#0072B2")) +
      labs(
        x = "Speed (mph)",
        y = "Acceleration (mph/s)",
        title = paste0(name, "'s Effort Quantile (95%)")
      ) +
      theme_minimal(base_size = 16) +
      theme(
        plot.title = element_text(face = "bold.italic", size = 18, hjust = .5),
        legend.title = element_text(face = "bold"),
        axis.title = element_text(face = "bold"),
        legend.text = element_text(size = 15),
        plot.caption = element_text(face = "italic", size = 8),
        legend.key.height = unit(1.4, "cm")
      ) +
      xlim(0, 25) +
      ylim(-15, 15)

    # Convert to plotly
    return(ggplotly(p, tooltip = "text"))
  }

  return(player_runs_test_preds)
}



#eff_function_qgam("James Cook", graph = TRUE)




# qgam_combined <- purrr::map(rbs_names, eff_function_qgam) |>
#   bind_rows()
# 
# qgam_dis <- qgam_combined |> 
#   mutate(diff_adj = ifelse(diff_a <= 0, 0, diff_a),
#          dis_score = 1 / (1 + diff_adj),
#          dis_score_adj = ifelse(dir_a_mpsh < 0, dis_score / 2, dis_score))
# 
# # Play level
# qgam_dis_play <- qgam_dis |> 
#   group_by(gameId, playId, bc_id, displayName) |> 
#   summarize(dis_score = mean(dis_score_adj)) |> 
#   ungroup()
# 
# # Player level
# qgam_dis_player <- qgam_dis |> 
#   group_by(bc_id, displayName) |> 
#   summarize(dis_score = mean(dis_score_adj)) |> 
#   ungroup() |> 
#   arrange(desc(dis_score)) |> 
#   mutate(dis_score = round(dis_score, 4) *100,
#          rank = 1:n())


```

```{r}
#| label: second-metric
#| message: false
#| warning: false
#| cache: true

# Player list
rb_dd_menu <- c("Saquon Barkley", "James Cook", "Chase Edmonds", "Rachaad White", "D'Andre Swift", 
                "Samaje Perine", "Joshua Kelley", "Alexander Mattison",
                "Josh Jacobs", "James Cook", "Melvin Gordon")

# Initialize plot
fig5 <- plot_ly()
all_traces <- list()
visibility_masks <- list()
trace_lengths <- c()

#Loop through each running back to collect their traces
for (i in seq_along(rb_dd_menu)) {
  player <- rb_dd_menu[i]
  plot_obj <- ggplotly(eff_function_qgam(player, graph = TRUE))
  
  player_traces <- list()
  for (trace in plot_obj$x$data) {
    if (trace$mode == "markers") {
    }
    trace$visible <- (i == 1) 
    
    # this is to display the first running back's AS quantile regression 
    fig5 <- fig5 |> add_trace(
      x = trace$x,
      y = trace$y,
      type = trace$type,
      mode = trace$mode,
      line = trace$line,
      marker = if (!is.null(trace$marker$color)) trace$marker else NULL,
      name = trace$name,
      text = trace$text,
      hoverinfo = trace$hoverinfo,
      visible = trace$visible
    )
    player_traces <- append(player_traces, list(trace))
  }
  
  all_traces[[i]] <- player_traces
  trace_lengths[i] <- length(player_traces)
}

#  Visibility masks for dropdown
total_traces <- sum(trace_lengths)

for (i in seq_along(rb_dd_menu)) {
  mask <- rep(FALSE, total_traces)
  start_index <- sum(trace_lengths[1:(i - 1)]) + 1
  end_index <- sum(trace_lengths[1:i])
  mask[start_index:end_index] <- TRUE
  visibility_masks[[i]] <- mask
}

# Adding dropdown menu
dropdown_buttons <- lapply(seq_along(rb_dd_menu), function(i) {
  list(
    method = "update",  # update both trace visibility and layout
    args = list(
      list(visible = visibility_masks[[i]]),  # traces to show
      list(title = list(text = paste0(rb_dd_menu[i], "'s Effort Quantile (95%)")))  # title change
    ),
    label = rb_dd_menu[i]
  )
})

fig5 <- fig5 |>
  layout(
    title = list(text = paste0(rb_dd_menu[1], "'s Effort Quantile (95%)")), 
    yaxis = list(title = "Acceleration (mph/s)"),
    xaxis = list(title = "Speed (mph)"),
    updatemenus = list(
      list(
        type = "dropdown",
        y = 0.6,
        x = 1.3,
        buttons = dropdown_buttons
      )
    )
  )
fig5


```



### Validation Model

To evaluate the predictive power of our effort metrics, we developed an Expected Points Added (EPA) over expected model. EPA is derived from Expected Points (EP), which estimates the number of points a team is likely to score on a drive based on the current game context. EPA is calculated as the difference between EP before and after a play, providing a measure of its contribution to a team’s scoring potential. 

EPA was selected as the outcome variable because it reflects the effectiveness of a play in terms of point value. To assess whether effort explains meaningful variance in play success, we computed correlations between model residuals and our effort metrics. A significant correlation would suggest that effort captures information not already explained by standard pre-play features. 

The model uses only variables available at the time of handoff to the RB. Including features from later in the play would introduce data leakage, since EPA is calculated only after the play is complete. Predictor variables include:

::: {.columns}
::: {.column width="50%"}
#### **Game context**
* Home field advantage
* Quarter
* Down
* Score differential

#### **Play context**
* Yards to go to a first down
* Yards to go to the endzone
* Number of blockers in front of the RB
* Number of defenders within 5 yards of the RB
* Offensive formation
* Run concept

:::

::: {.column width="50%"}

#### **RB characteristics**
* Speed
* Directional acceleration
* Weight
* Positional coordinates of RB on field

#### **Nearest defender characteristics**
* Speed
* Directional acceleration
* Angle with the RB
* Distance to RB

:::
:::


We used a random forest model for its ability to capture nonlinear relationships and reduce the risk of overfitting. We performed 5-fold cross validation, assigning entire games to individual folds to mitigate possible dependencies.

## Results

::: {.columns}
::: {.column width="40%"}
![](photos_right/Effort1Rank.png){width=60%}
:::

::: {.column width="40%"}
![](photos_right/Effort2Rank.png){width=60%}
:::
:::


Our findings indicate that backup RBs consistently exhibit higher frame-level effort across both metrics compared to starters. This may reflect a tendency to capitalize on limited playing time by more frequently approaching or exceeding their individual maximum acceleration frontiers. Playing fewer snaps also likely reduces cumulative fatigue, enabling backups to sustain higher-effort movements when on the field. Conversely, starters may possess greater innate talent, physical ability, or experience, allowing them to achieve comparable or superior performance with less exertion per play.

![](photos_right/EffMetrics.png){width=80%}

The two metrics are positively correlated, as expected given their similar derivation. Both were ultimately designed to capture the same underlying concept: how a RB’s observed acceleration compares to their individual maximum acceleration frontier. 

::: {.panel-tabset}
### Effort vs. Max Acceleration
![](photos_right/MaxAcc.png){width=80%}

### Effort vs. Max Speed
![](photos_right/MaxSpeed.png){width=80%}

### Effort vs. Number of Rushes
![](photos_right/NumRushes.png){width=80%}
:::

### Validation Model

![](photos/Rf_preds.png){width=80%}

Our expected EPA model yielded a root mean squared error (RMSE) of 0.929. Given that EPA values typically range from -10 to +6, this level of error is acceptable. However, the random forest model demonstrates limited accuracy on plays with extreme EPA values. It is plausible to initially speculate that this underperformance stems from the model’s omission of effort as a predictor, impairing its ability to fully explain EPA variation.

![](photos_right/EPAResiduals.png){width=80%}

The correlations between model residuals and each effort metric were weak, indicating that the model’s prediction errors are likely not due to the absence of effort-based features, contrary to our initial hypothesis. This suggests that effort—as defined by proximity to the maximum acceleration frontier–does not reliably predict deviations from expected play value, and thus may not necessarily translate to better on-field performance.  

![](photos_right/EffortCorrelations.png){width=80%}

Further analysis confirms this result: both effort metrics show relatively low correlation with several play outcome variables. Taken together, these findings corroborate that effort, by our definition, does not directly contribute to superior results. 


## Discussion

A-S-based effort, while measurable and player-specific, is insufficient on its own to explain RB performance. A player’s ability to consistently reach or exceed their individual maximum acceleration frontier might indicate physical exertion, intent, or athletic capacity, but it does not directly correspond to play outcomes such as rushing yards and EPA. This implies that effort, as captured by our metrics, reflects only one dimension of performance—namely, the intensity of a player’s movement—while omitting cognitive, tactical, and contextual influences that likely play an equal or greater role in shaping on-field outcomes. As such, A-S-based effort should be interpreted as a complementary metric rather than a standalone indicator of performance or effectiveness.  

Quantifying effort remains a complex task with no single definitive solution. Nonetheless, isolating and measuring its physical component provides a concrete foundation for developing more comprehensive metrics in the future. 

### Limitations
A key limitation of our effort metrics is their inability to fully account for player and game context. For instance, if a RB decelerates sharply due to a tackle, the model interprets this deceleration as effortful—despite it being the result of external contact rather than intentional exertion. By omitting physical interactions or play-specific dynamics, the metrics risk misclassifying non-effortful outcomes. A more robust alternative might involve modeling expected acceleration based on situational variables and using these predictions—rather than observed values—in the A-S profile to better capture true exertion.

Another shortcoming arises from the individualized nature of each player’s A-S profile. While this approach accounts for physical differences between players, it holds each to a different standard. For example, athletically gifted players, such as Christian McCaffrey, generate higher 0.95 quantile acceleration curves, thereby requiring greater exertion to meet the same relative effort threshold. In other words, the same level of physical output may be classified differently depending on the athlete’s profile, complicating comparisons across players.

Finally, our use of EPA over expected as a validation method may not fully isolate the RB’s individual contribution. Since EPA is influenced by various external and team-level factors outside of the RB’s direct control (e.g., offensive efficiency, blocking, play calling), it does not exclusively reflect the impact of a single player’s effort. Consequently, high EPA plays might be driven more by team execution than personal exertion. Validating against metrics more directly attributable to RB-specific action may offer a clearer assessment of our approach. 

### Future Work
A natural extension of this study is applying the effort metrics to wide receivers. One area of interest is how a receiver's effort differs when they anticipate being targeted versus when they do not. By examining how often a receiver approaches or exceeds their maximum acceleration frontier in each scenario, we can evaluate whether effort remains consistent regardless of play assignment.

Another direction involves refining our definition of effort to more accurately reflect its relationship with performance. While our current metrics measure how often a RB attains near-maximal acceleration, they do not directly account for whether this effort translates into successful play outcomes. Given the subjective and context-dependent nature of effort, future research may involve integrating additional situational or performance-based variables to better link exertion with effectiveness. 


## Acknowledgements
Many thanks to Sam Ventura from the Buffalo Sabres for his guidance and mentorship throughout the project. We are grateful for the time and dedication Sam has put into this work.
We also want to thank Quang Nguyen for his instruction, advice, and support throughout the summer research experience. Quang had provided us with the resources necessary to get started with the NFL Big Data Bowl tracking data. Finally, we would like to thank Dr. Ron Yurko and the CMSAC teaching staff for sharing with us their knowledge and inspiring ideas. 


## References
<div style="text-indent: -1.7em; padding-left: 1.7em; margin-bottom: 1em;">
[1] Morin, J., Mat, Y. L., Osgnach, C., Barnabò, A., Pilati, A., Samozino, P., & Di Prampero, P. E. (2021). Individual acceleration-speed profile in-situ: A proof of concept in professional football players. Journal of Biomechanics, 123, 110524. https://doi.org/10.1016/j.jbiomech.2021.110524
</div>

<div style="text-indent: -1.7em; padding-left: 1.7em; margin-bottom: 1em;">
[2] Michael Lopez, Thompson Bliss, Ally Blake, Paul Mooney, and Addison Howard. NFL Big Data Bowl 2025. https://kaggle.com/competitions/nfl-big-data-bowl-2025, 2024. Kaggle.
</div>

<div style="text-indent: -1.7em; padding-left: 1.7em; margin-bottom: 1em;">
[3] Hader, K., Mendez-Villanueva, A., Palazzi, D., Ahmaidi, S., & Buchheit, M. (2016). Metabolic Power Requirement of Change of Direction Speed in Young Soccer Players: Not All Is What It Seems. PloS one, 11(3), e0149839. https://doi.org/10.1371/journal.pone.0149839
</div>

