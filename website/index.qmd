---
title: "Tracking the Intangible: Quantifying Effort in NFL Running Backs"
author:
- "Emily Shteynberg"
- "Luke Snavely"
- "Sheryl Solorzano"
date: "July 25, 2025"
format:
  html:
    html-math-method: katex
    self-contained: true
execute:
  echo: false
  warning: false
  message: false
bibliography: bib/library.bib
---

```{r}
#| label: setup
#| include: false

# Load necessary packages
library(tidyverse)
library(knitr)
library(ggplot2)
library(plotly)
library(tidytext)
library(quantreg)
library(qgam)
library(knitr)
library(kableExtra)

```

```{r}
#| fig-width: 8
#| fig-height: 4
#| out.width: "85%"
#| fig-align: "center"


include_graphics("docs/images/NFL2022.png")

```

*Image source: [The Tower](https://sbadamsthetower.com/7756/sports/2022-2023-nfl-preview/)*




---

## Introduction 

Effort is a fundamental and yet often invisible and subjective dimension of athletic performance. In American Football, one of the most-watched and popular sports in the U.S., known for its quick decision-making, complex tactics, and athletically demanding displays of strength, endurance, and speed, traditional statistics like yards after contact or expected points added tend to focus on outcomes rather than the process behind them. This raises important questions: What does it take to gain a yard? Is a player exceeding their capabilities, therefore, making an effort? If so, how often or how close does a player come to their “best"?

These questions are at the heart of our project. While previous research in professional soccer has used theoretical maximum acceleration as a proxy for effort, no such framework currently exists in the NFL. Our goal is to address that gap by developing a player-specific, data-driven metric for measuring effort among running backs (RBs). Specifically, we focus on physical effort as expressed through raw acceleration and speed, which are variables we can observe directly in player tracking data.

Effort, of course, is a complex, intangible, and most often subjective concept, influenced by mental and emotional state of a player as well as tactical and game factors, including player position, opposing defense, snap count or play volume to play call/assignment, and other game context. However, given the data available, we concentrate on one measurable facet: a player’s movement relative to his individual maximum capabilities. Using statistical models, we estimate each RB’s personal performance ceiling and assess how frequently and how closely they approach it during games.

By quantifying effort, we hope to provide not only to teams and sport data analysts, but also fans with deeper insights into how much football players are truly contributing on the field — even if they’re not reflected in conventional stats or the outcome of a game. In doing so, we also aim to contribute to a growing body of research around quantifying effort since most research focuses on win probabilities and other outcomes at the game level rather than at the individual level.



## Data

The data used for this project were the games, plays, players, tracking data sets from the NFL Big Data Bowl 2025, weeks 1-9 on Kaggle [@nfl2022].

#### Data pre-porcessing

 - We limited our dataset to NFL running backs with more than 20 rushes per play during the 2022 season.
 - We limited the rows to running plays where a running back (RB) is the ball carrier.
 - We Trimmed each play to frames between handoff and at end of a play.
 

## Methods

In this project, we define effort as a running back's ability to consistently reach a combination of their individual maximal acceleration for any given speed.

### Metric #1: Linear Regression

- Our main methodological approach to addressing this question centered around previous research that has explored soccer players reaching their theoretical max acceleration capacity for every running speed [@AS]. Similarly, we adopted this framework by plotting an individual running back's profile based on the maximal acceleration the running back could generate for every possible running speed as follows:

   - Within a speed interval ranging between 3 mph and the RB’s maximal speed, the two maximal acceleration values attained for each 0.2 mph sub-intervals were selected. 
   - A first linear regression was fit to these speed-acceleration points. 
   - Outlier points lying outside of 95% confidence interval around the linear function were removed. 
   - A linear regression was fit to the remaining points.
  
- This effort metric was derived by transforming final regression line downward by 0.25 units.
- **Effort =** percentage of points above the transformed regression line


### Qgam

```{r}
#| label: effort-metric-one
#| fig-cap: "......"
#| message: false
#| warning: false
#| cache: true

load("web_data/tracking_bc.Rdata")
load("web_data/player_runs_modeling.Rdata")

# qgam right --------------------------------------------------------------

eff_function_qgam <- function(name, graph = FALSE) {
  # Choosing player name
  player_runs <- tracking_bc |> 
    filter(displayName == name)
  
  # Making the modeling data frame
  player_runs_modeling <- player_runs |> 
    select(s_mph, dir_a_mpsh, gameId, displayName, bc_id, playId, frameId)
  
  # Data to be in model
  data_pos <- player_runs_modeling |> 
    filter(dir_a_mpsh >= 0)
  
  data_neg <- player_runs_modeling |> 
    filter(dir_a_mpsh < 0)
    
  # Models
  # speed_99 <- quantile(player_runs_modeling$s_mph, probs = c(.99))
  
  qgam_fit_a_top <- qgam(dir_a_mpsh ~ s(s_mph, k = 10, bs = "ad"),
                         data = data_pos,
                         qu = .95,
                         multicore = TRUE,
                         ncores = 7)
  
  qgam_fit_a_bottom <- qgam(dir_a_mpsh ~ s(s_mph, k = 10, bs = "ad"),
                            data = data_neg,
                            qu = .05,
                            multicore = TRUE,
                            ncores = 7)
  
  data_pos_final <- data_pos |> 
    mutate(qgam_pred = qgam_fit_a_top$fitted.values,
           diff_a = qgam_pred - dir_a_mpsh)
  
  data_neg_final <- data_neg |> 
    mutate(qgam_pred = qgam_fit_a_bottom$fitted.values,
           diff_a = dir_a_mpsh - qgam_pred)

    
    # Combining positive and negative vals
    player_runs_test_preds <- rbind(data_pos_final, data_neg_final)
  
  if (graph == TRUE) {
    out_line <- player_runs_test_preds |> 
      filter(diff_a <= 0)
    
    player_graph <- player_runs_test_preds |> 
      ggplot(aes(x = s_mph, y = dir_a_mpsh)) +
      geom_point(alpha=.6, color="grey2")+
      geom_point(data = out_line, aes(x = s_mph, y = dir_a_mpsh, fill = "Adjusted distance = 0"), size = 4, 
                 stroke = 1.2, color="black", shape = 21) +
      geom_line(data = data_pos_final, aes(y = qgam_pred, color = "0.95 quantile accel. \nregression line"), lwd = 1.2) +
      geom_line(data = data_neg_final, aes(y = qgam_pred, color = "0.95 quantile decel. \nregression line"), lwd = 1.2) +
      # geom_vline(aes(color = "Speed 0.99 quantile line", 
      #                xintercept = quantile(s_mph, probs = c(.99))), 
      #            lty = 2, lwd = 1.5) +
      geom_hline(aes(yintercept = 0), color = "black", lwd = 1.2, lty = 2) +
      scale_color_manual("Line", values = c("#D55E00", "#0072B2")) +
      scale_fill_manual("Point", values = c("#b3b3b3")) +
      labs(x = "Speed (mph)",
           y = "Acceleration (mph/s)",
           title = paste0(name, "'s effort score: 22.60%")) +
      theme_minimal(base_size=16) +
      theme(plot.title = element_text(face = "bold.italic",
                                      size = 18, 
                                      hjust = .5),
            legend.title = element_text(face = "bold"),
            axis.title = element_text(face = "bold"),
            legend.text=element_text(size=15),
            plot.caption = element_text(face = "italic", size = 8),
            legend.key.height = unit(1.4, "cm")) +
      xlim(0, 25) +
      ylim(-15, 15)
    return(player_graph)
  }
  return(player_runs_test_preds)
}

eff_function_qgam("James Cook", graph = TRUE)
eff_function_qgam("Saquon Barkley", graph = TRUE)

qgam_combined <- purrr::map(rbs_names, eff_function_qgam) |>
  bind_rows()

qgam_dis <- qgam_combined |> 
  mutate(diff_adj = ifelse(diff_a <= 0, 0, diff_a),
         dis_score = 1 / (1 + diff_adj),
         dis_score_adj = ifelse(dir_a_mpsh < 0, dis_score / 2, dis_score))

# Play level
qgam_dis_play <- qgam_dis |> 
  group_by(gameId, playId, bc_id, displayName) |> 
  summarize(dis_score = mean(dis_score_adj)) |> 
  ungroup()

# Player level
qgam_dis_player <- qgam_dis |> 
  group_by(bc_id, displayName) |> 
  summarize(dis_score = mean(dis_score_adj)) |> 
  ungroup() |> 
  arrange(desc(dis_score)) |> 
  mutate(dis_score = round(dis_score, 4) *100,
         rank = 1:n())


```



### linear regression

```{r}
#| label: linear-regression
#| fig-cap: "Linear quantile regression for acceleration(mph/s) vs speed(mph)"

load("web_data/tracking_bc.Rdata")
load("web_data/player_runs_modeling.Rdata")

eff_function <- function(name, graph = FALSE, player_table = FALSE) {
  # Filter data for selected player
  player_runs <- tracking_bc |> 
    filter(displayName == name)
  
  # Speed bins
  bins <- seq(3, round(max(player_runs$s_mph), 2) + .2, .2)

  # Select top-2 acceleration points per bin
  max_acc <- map_dfr(1:(length(bins) - 1), function(i) {
    player_runs |> 
      filter(s_mph > bins[i], s_mph <= bins[i + 1]) |> 
      slice_max(a_mpsh, n = 2, with_ties = FALSE) |> 
      select(speed = s_mph, acceleration = a_mpsh)
  })
  
  # Fit linear model
  player_lm <- lm(acceleration ~ speed, data = max_acc)
  confs <- predict(player_lm, interval = "confidence")
  max_acc <- bind_cols(max_acc, confs)
  
  # Filter outliers outside 95% CI
  max_acc_clean <- max_acc |> 
    filter(acceleration >= lwr, acceleration <= upr)
  
  # Refit linear model
  player_lm_clean <- lm(acceleration ~ speed, data = max_acc_clean)
  
  # Predicted values and difference from fitted line
  test_player_a <- tibble(speed = player_runs$s_mph, acceleration = player_runs$a_mpsh)
  test_preds <- predict(player_lm_clean, newdata = test_player_a)
  
  player_final <- player_runs |> 
    select(a_mpsh, s_mph) |> 
    mutate(pred = test_preds,
           diff = pred - a_mpsh,
           eff = diff <= 0.25,
           eff_50 = diff <= 0.5,
           eff_75 = diff <= 0.75,
           gameId = player_runs$gameId,
           playId = player_runs$playId,
           bc_id = player_runs$bc_id,
           displayName = player_runs$displayName,
           frameId = player_runs$frameId)
  
  # Summary effort score
  eff <- tibble(
    eff_metric = sum(player_final$eff, na.rm = TRUE),
    eff_metric_perc = sum(player_final$eff, na.rm = TRUE) / nrow(player_final) * 100,
    eff_metric_50 = sum(player_final$eff_50, na.rm = TRUE),
    eff_metric_perc_50 = sum(player_final$eff_50, na.rm = TRUE) / nrow(player_final) * 100,
    eff_metric_75 = sum(player_final$eff_75, na.rm = TRUE),
    eff_metric_perc_75 = sum(player_final$eff_75, na.rm = TRUE) / nrow(player_final) * 100
  )
  
  if (graph == TRUE) {
    # Build regression lines
    intercept <- player_lm_clean$coefficients[1]
    slope <- player_lm_clean$coefficients[2]
    s_seq <- seq(min(player_runs$s_mph), max(player_runs$s_mph), length.out = 200)
    
    reg_df <- tibble(
      speed = s_seq,
      reg = intercept + slope * s_seq,
      reg_minus_025 = intercept - 0.25 + slope * s_seq
    )
    
    # Plotly plot
    p <- ggplot(player_final, aes(x = s_mph, y = a_mpsh)) +
      geom_point(aes(text = paste0("Speed: ", round(s_mph, 2), "<br>Accel: ", round(a_mpsh, 2))), 
                 color = "grey20", alpha = 0.55) +
      geom_line(data = reg_df, aes(x = speed, y = reg, color = "Regression line"), size = 1.2) +
      geom_line(data = reg_df, aes(x = speed, y = reg_minus_025, color = "Regression line - 0.25"), 
                linetype = "dashed", size = 1.2) +
      scale_color_manual("Line", values = c("Regression line" = "#0072B2", 
                                            "Regression line - 0.25" = "#D55E00")) +
      labs(
        title = paste0(name, "'s Effort: ", round(eff$eff_metric_perc, 2), "%"),
        x = "Speed (mph)",
        y = "Acceleration (m/s²)",
        caption = "Effort defined as within 0.25 m/s² of fitted top acceleration"
      ) +
      theme_minimal(base_size = 16) +
      theme(
        plot.title = element_text(face = "bold", hjust = 0.5, size = 18),
        axis.title = element_text(face = "bold", size = 14),
        axis.text = element_text(size = 12),
        legend.title = element_text(face = "bold"),
        legend.text = element_text(size = 13),
        plot.caption = element_text(face = "italic", size = 10)
      )

    return(ggplotly(p, tooltip = "text"))
  }
  
  if (player_table == TRUE) {
    return(player_final)
  }

  return(eff)
}

# testing one player
eff_function("Saquon Barkley", graph = TRUE)


#===================[ making interactive drop down menu ]=======================

# rb_dd_list <- c("Saquon Barkley", "Rex Burkhead", "Chase Edmonds", "Rachaad White", "D'Andre Swift", 
#                 "Samaje Perine", "Joshua Kelley", "Matt Breida", "Alexander Mattison",
#                 "Josh Jacobs", "James Cook", "Melvin Gordon")
# 
# # Initialize plot
# fig2 <- plot_ly()
# all_traces <- list()
# visibility_masks <- list()
# trace_lengths <- c()
# 
# #Loop through each running back to collect their traces
# for (i in seq_along(rb_dd_list)) {
#   player <- rb_dd_list[i]
#   plot_obj <- ggplotly(eff_function_qgam(player, graph = TRUE))
#   
#   player_traces <- list()
#   for (trace in plot_obj$x$data) {
#     trace$visible <- (i == 1) 
#     
#     # this is to display the first running back's AS quantile regression 
#     fig2 <- fig2 |> add_trace(
#       x = trace$x,
#       y = trace$y,
#       type = trace$type,
#       mode = trace$mode,
#       line = trace$line,
#       name = trace$name,
#       text = trace$text,
#       hoverinfo = trace$hoverinfo,
#       visible = trace$visible
#     )
#     player_traces <- append(player_traces, list(trace))
#   }
#   
#   all_traces[[i]] <- player_traces
#   trace_lengths[i] <- length(player_traces)
# }
# 
# #  Visibility masks for dropdown
# total_traces <- sum(trace_lengths)
# 
# for (i in seq_along(rb_dd_list)) {
#   mask <- rep(FALSE, total_traces)
#   start_index <- sum(trace_lengths[1:(i - 1)]) + 1
#   end_index <- sum(trace_lengths[1:i])
#   mask[start_index:end_index] <- TRUE
#   visibility_masks[[i]] <- mask
# }
# 
# # Adding dropdown menu
# dropdown_buttons <- lapply(seq_along(rb_dd_list), function(i) {
#   list(method = "restyle",
#        args = list("visible", visibility_masks[[i]]),
#        label = rb_dd_list[i])
# })
# 
# fig2 <- fig2 |>
#   layout(
#     title = "Acceleration vs Speed Individualized Profile by Running Back",
#     updatemenus = list(
#       list(
#         type = "dropdown",
#         y = 0.8,
#         x = 1.1,
#         buttons = dropdown_buttons
#       )
#     )
#   )
# fig2


```

### Metric #2: Additive Quantile Regression Model

- This metric quantifies *how often* a runnng back comes close to their maximal acceleration capacity.
- **Assumption of this effort metric:** high acceleration and/or high speed movements are effortful.
- For each running back, two regression models with adaptive spline bases were fitted to the 0.98 quantiles of positive and negative acceleration, respectively, both as functions of running speed. A vertical line at the 0.99 quantile of speed was also drawn. 
- This metric was derived by 

             [LATEX equation] 

where di is the shortest distance from each point to its corresponding quantile regression line (either for positive or negative acceleration) or to the vertical line at the 0.99 quantile of speed.

   - For points outside the quantile regression lines and/or the vertical line, the distance di was set to 0. 
   - For negative acceleration points, **the effort score[change]** was penalized with by a factor of 0.5 as deceleration is deemed less effortful.
   
   
   
   
```{r}
#| label: effort-metric-two
#| fig-cap: "....."
#| message: false
#| warning: false
#| cache: true

eff_function_nlrq <- function(name, graph = FALSE) {
  # Choosing player name
  player_runs <- tracking_bc |> 
    filter(displayName == name)
  
  # Making the modeling data frame
  player_runs_modeling <- player_runs |> 
    select(s_mph, dir_a_mpsh, gameId, displayName, bc_id, playId, frameId)
  
  # Data to be in model
  data_pos <- player_runs_modeling |> 
    filter(dir_a_mpsh >= 0)
  
  data_neg <- player_runs_modeling |> 
    filter(dir_a_mpsh < 0)
  
  # Models
  nlrq_pos <- nlrq(dir_a_mpsh ~ x * s_mph^2 + y * s_mph + z,
                   data = data_pos,
                   tau = .95,
                   start = list(x = 10, y = 2, z = 5))

  nlrq_neg <- nlrq(dir_a_mpsh ~ x * s_mph^2 + y * s_mph + z,
                   data = data_neg,
                   tau = .05,
                   start = list(x = 10, y = 2, z = 5))
  
  data_pos_final <- data_pos |> 
    mutate(nlrq_pred = nlrq_pos$m$fitted(),
           diff_a = nlrq_pred - dir_a_mpsh)
  
  data_neg_final <- data_neg |> 
    mutate(nlrq_pred = nlrq_neg$m$fitted(),
           diff_a = dir_a_mpsh - nlrq_pred)
  
  
  # Combining positive and negative vals
  player_runs_test_preds <- rbind(data_pos_final, data_neg_final)
  
  if (graph == TRUE) {
    out_line <- player_runs_test_preds |> 
      filter(diff_a <= 0)
    
    player_graph <- player_runs_test_preds |> 
      ggplot(aes(x = s_mph, y = dir_a_mpsh)) +
      geom_point(alpha=.6, color="grey2")+
      geom_point(data = out_line, aes(x = s_mph, y = dir_a_mpsh, fill = "Adjusted distance = 0"), size = 4, 
                 stroke = 1.2, color="black", shape = 21) +
      geom_line(data = data_pos_final, aes(y = nlrq_pred, color = "0.95 quantile accel. \nregression line"), lwd = 1.2) +
      geom_line(data = data_neg_final, aes(y = nlrq_pred, color = "0.95 quantile decel. \nregression line"), lwd = 1.2) +
      geom_hline(aes(yintercept = 0), color = "black", lwd = 1.2, lty = 2) +
      scale_color_manual("Line", values = c("#D55E00", "#0072B2", "goldenrod")) +
      scale_fill_manual("Point", values = c("#b3b3b3")) +
      labs(x = "Speed (mph)",
           y = "Acceleration (mph/s)",
           title = paste0(name, "'s effort score: 18.65%")) +
      theme_minimal(base_size=16) +
      theme(plot.title = element_text(face = "bold.italic",
                                      size = 18, 
                                      hjust = .5),
            legend.title = element_text(face = "bold"),
            axis.title = element_text(face = "bold"),
            legend.text=element_text(size=15),
            plot.caption = element_text(face = "italic", size = 8),
            legend.key.height = unit(1.4, "cm"),
            legend.position = "right") +
      xlim(0, 25) +
      ylim(-15, 15)
    return(player_graph)
  }
  return(player_runs_test_preds)
}

eff_function_nlrq("James Cook", graph = TRUE)
eff_function_nlrq("Saquon Barkley", graph = TRUE)
nlrq_combined <- purrr::map(rbs_names, eff_function_nlrq) |>
  bind_rows()

nlrq_dis <- nlrq_combined |> 
  mutate(diff_adj = ifelse(diff_a <= 0, 0, diff_a),
         dis_score = 1 / (1 + diff_adj),
         dis_score_adj = ifelse(dir_a_mpsh < 0, dis_score / 2, dis_score))

# Play level
nlrq_dis_play <- nlrq_dis |> 
  group_by(gameId, playId, bc_id, displayName) |> 
  summarize(dis_score = mean(dis_score_adj)) |> 
  ungroup()

# Player level
nlrq_dis_player <- nlrq_dis |> 
  group_by(bc_id, displayName) |> 
  summarize(dis_score = mean(dis_score_adj)) |> 
  ungroup() |> 
  arrange(desc(dis_score)) |> 
  mutate(dis_score = round(dis_score, 4) *100,
         rank = 1:n())


```



```{r}
#| label: percentile-lines-regression
#| fig-cap: "Percentage of total points that lie in between the percentile $P_{99}$ and $P_{99}-3$"

# NOTE: takes a bit to run since the function is iterating through a lot of players! >:(

#================ [Interactive drop down menu to select any running backs (syntax)]================#

eff_function_qgam <- function(name, graph = FALSE) {
  # Filter player runs
  player_runs <- tracking_bc |> 
    filter(displayName == name)
  
  # Define folds
  N_FOLDS <- 5
  
  # Assign folds by game
  plays_folds <- player_runs |> 
    distinct(gameId) |> 
    mutate(fold = sample(rep(1:N_FOLDS, length.out = n())))
  
  # Merge with folds and select modeling variables
  player_runs_modeling <- player_runs |> 
    select(s_mph, a_mpsh, gameId) |> 
    left_join(plays_folds, by = "gameId") |> 
    select(-gameId)

  # Cross-validation logic
  player_runs_cv <- function(x) {
    test_data <- player_runs_modeling |> filter(fold == x)
    train_data <- player_runs_modeling |> filter(fold != x)
    
# trying to suppress messages from qgam() model in the final rendered file
    
    suppressMessages({
  suppressWarnings({
    capture.output({
      qgam_fit <- qgam(
        a_mpsh ~ s(s_mph, k = 15, bs = "ad"),
        data = train_data,
        qu = .99,
        multicore = TRUE,
        ncores = 7
      )
    })
  })
})

    tibble(
      displayName = name,
      qgam_pred = predict(qgam_fit, newdata = test_data),
      actual_acc = test_data$a_mpsh,
      actual_speed = test_data$s_mph,
      res = test_data$a_mpsh - predict(qgam_fit, newdata = test_data),
      qgam_pred_minus_3 = predict(qgam_fit, newdata = test_data) - 3,
      test_fold = x
    )
  }

  # Run CV and collect predictions
  player_runs_test_preds <- map(1:N_FOLDS, player_runs_cv) |> 
    bind_rows()

  # Compute effort score (proportion below the 99th percentile line)
  eff_score <- mean(player_runs_test_preds$res < 0)

  if (graph == TRUE) {
    # Fit final GAM lines for plotting
    gam_fit_99 <- mgcv::gam(qgam_pred ~ s(actual_speed, k = 15, bs = "ad"), data = player_runs_test_preds)
gam_fit_99m3 <- mgcv::gam(qgam_pred_minus_3 ~ s(actual_speed, k = 15, bs = "ad"), data = player_runs_test_preds)

    s_seq <- seq(min(player_runs_test_preds$actual_speed, na.rm = TRUE),
                 max(player_runs_test_preds$actual_speed, na.rm = TRUE),
                 length.out = 200)
    pred_df <- tibble(
      s = s_seq,
      pred_99 = predict(gam_fit_99, newdata = tibble(actual_speed = s_seq)),
      pred_99m3 = predict(gam_fit_99m3, newdata = tibble(actual_speed = s_seq))
    )

    # ggplot
    p <- ggplot() +
      geom_point(data = player_runs_test_preds %>% mutate(color = "gray"), aes(
        x = actual_speed, 
        y = actual_acc,
        color = color,
        text = paste0("Speed: ", round(actual_speed, 2),
                      "<br>Acceleration: ", round(actual_acc, 2))), 
      alpha = 0.55, 
      # so the data point's color doesn't show on the legend
      show.legend = FALSE) + 
      geom_line(data = pred_df, aes(x = s, y = pred_99, color = "99th percentile"), size = 1.2) +
      geom_line(data = pred_df, aes(x = s, y = pred_99m3, color = "99th percentile - 3"), linetype = "dashed", size = 1.2) +
      scale_color_manual(values = c("99th percentile" = "#0072B2", "99th percentile - 3" = "black")) +
      labs(
        title = paste0(name, "'s Effort Quantile Curve (99%)"),
        x = "Speed (mph)",
        y = "Acceleration (m/s²)",
        caption = "Data from Weeks 1–9 of the 2022 NFL Season"
      ) +
      theme_minimal(base_size = 16) +
      theme(
        plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
        axis.title = element_text(face = "bold", size = 14),
        axis.text = element_text(size = 12),
        legend.title = element_text(face = "bold"),
        legend.text = element_text(size = 13),
        plot.caption = element_text(face = "italic", size = 10)
      )

    return(ggplotly(p, tooltip = "text"))
  }

  return(tibble(displayName = name, effort_ratio_99 = 1 - eff_score))
}
```


###  Top Running backs
```{r}
#| label: top-players
#| fig-cap: "Top 10"
#| message: false
#| warning: false
#| cache: true

# Player list
rb_dd_list <- c("Chase Edmonds", "Rachaad White", "D'Andre Swift", 
                "Samaje Perine", "Joshua Kelley", "Matt Breida", "Alexander Mattison",
                "Josh Jacobs", "James Cook", "Melvin Gordon")

# Initialize plot
fig2 <- plot_ly()
all_traces <- list()
visibility_masks <- list()
trace_lengths <- c()

#Loop through each running back to collect their traces
for (i in seq_along(rb_dd_list)) {
  player <- rb_dd_list[i]
  plot_obj <- ggplotly(eff_function_qgam(player, graph = TRUE))
  
  player_traces <- list()
  for (trace in plot_obj$x$data) {
    if (trace$mode == "markers") {
      trace$marker$color <- "grey40"
      trace$marker$line$color <- "grey40"
    }
    trace$visible <- (i == 1) 
    
    # this is to display the first running back's AS quantile regression 
    fig2 <- fig2 |> add_trace(
      x = trace$x,
      y = trace$y,
      type = trace$type,
      mode = trace$mode,
      line = trace$line,
      marker = trace$marker,
      name = trace$name,
      text = trace$text,
      hoverinfo = trace$hoverinfo,
      visible = trace$visible
    )
    player_traces <- append(player_traces, list(trace))
  }
  
  all_traces[[i]] <- player_traces
  trace_lengths[i] <- length(player_traces)
}

#  Visibility masks for dropdown
total_traces <- sum(trace_lengths)

for (i in seq_along(rb_dd_list)) {
  mask <- rep(FALSE, total_traces)
  start_index <- sum(trace_lengths[1:(i - 1)]) + 1
  end_index <- sum(trace_lengths[1:i])
  mask[start_index:end_index] <- TRUE
  visibility_masks[[i]] <- mask
}

# Adding dropdown menu
dropdown_buttons <- lapply(seq_along(rb_dd_list), function(i) {
  list(method = "restyle",
       args = list("visible", visibility_masks[[i]]),
       label = rb_dd_list[i])
})

fig2 <- fig2 |>
  layout(
    title = "Acceleration vs Speed Individualized Profile by Running Back",
    updatemenus = list(
      list(
        type = "dropdown",
        y = 0.8,
        x = 1.1,
        buttons = dropdown_buttons
      )
    )
  )
fig2


```



## Results

**[Describe your results. This can include tables and plots showing your results, as well as text describing how your models worked and the appropriate interpretations of the relevant output. (Note: Don’t just write out the textbook interpretations of all model coefficients. Instead, interpret the output that is relevant for your question of interest that is framed in the introduction)]]**




### scatterplot

```{r}
#| label: results-scatterplot
#| fig-cap: "correlation between metric #1 and metric #2"
#| message: false
#| warning: false
#| cache: true

## Scatterplot
dis_scatter <- qgam_dis_player |> 
  mutate(dis_score_qgam = dis_score,
         rank_qgam = rank) |> 
  select(-dis_score, -rank) |> 
  left_join(nlrq_dis_player, by = c("bc_id", "displayName"))

label_names <- dis_scatter |> 
  filter(rank_qgam <= 6 | rank <= 6 | rank_qgam >=64 
         | rank >= 64 | displayName %in% c("Saquon Barkley", "James Cook"))

dis_scatter |> 
  ggplot(aes(x = dis_score, y = dis_score_qgam)) +
  geom_hline(aes(yintercept = mean(dis_score_qgam)), lwd = 1.2, lty = 2, color = "#D50A0A") +
  geom_vline(aes(xintercept = mean(dis_score)), lwd = 1.2, lty = 2, color = "#D50A0A") +
  geom_point(aes(color = dis_score), size = 3, alpha = .8) +
  scale_color_gradient(low = "#0072B2", high = "#D55E00") +
  labs(title = "Player effort metrics positively correlate with each other",
       x = "Effort metric #1 (non-linear quantile regression)",
       y = "Effort metric #2 (GAM quantile regression)")+
  theme_minimal(base_size=16) +
  theme(plot.title = element_text(face = "bold.italic",
                                  size = 18, 
                                  hjust = .5),
        legend.position = "none",
        axis.title = element_text(face = "bold")) +
  ggrepel::geom_text_repel(data = label_names, aes(label = displayName), 
                           size = 5, max.overlaps = 15,
                           fontface = "italic")
  
```




## Discussion

**[Give your conclusions and summarize what you have learned with regards to your question of interest. Are there any limitations with the approaches you used? What do you think are the next steps to follow-up your project?]**

- AS profile framework didn't translate into football (maybe it works for other sports where players don't get tackled but just run at hand-off)
- there are many dependencies in NFL
- this is a productive place to start quantifying effort
- further research should look into taking into account other factors/variables


## Appendix



## Trying a different interactive layout

::: {.panel-tabset}

### Tab 1: Saquon Barkley
```{r}
##| label: fig-quant-1
##| fig-cap: "trying non-linear-quant-regression"

# load("web_data/tracking_bc.Rdata")
# load("web_data/player_runs_modeling.Rdata")
# 
# 
# set.seed(1)
# 
# eff_function_rqss <- function(name, graph = FALSE) {
#   player_runs <- tracking_bc |> 
#     filter(displayName == name)
# 
#   N_FOLDS <- 5
#   player_runs_modeling <- player_runs |> 
#     select(s, a) |> 
#     mutate(fold = sample(rep(1:N_FOLDS, length.out = n())))
#   
#   player_runs_cv <- function(x) {
#     test_data <- player_runs_modeling |> 
#       filter(fold == x)
#     train_data <- player_runs_modeling |> 
#       filter(fold != x)
#     
#     s_range <- range(train_data$s)
#     test_data <- test_data |> 
#       filter(s >= max(s_range[1], 1),
#              s <= min(s_range[2], 9))
#     
#     rq_fit <- rqss(a ~ qss(s, lambda = 3), tau = 0.9, data = train_data)
#     
#     out <- tibble(
#       rq_pred = predict(rq_fit, newdata = test_data),
#       test_actual = test_data$a,
#       res_rq = test_actual - rq_pred,
#       test_fold = x
#     )
#     return(out)
#   }
# 
#   player_runs_test_preds <- map(1:N_FOLDS, player_runs_cv) |> 
#     list_rbind()
#   
#   eff_score <- mean(player_runs_test_preds$res_rq < 0)
# 
#   if (graph == TRUE) {
#     # Fit final model and compute smooth prediction line
#     rq_fit <- rqss(a ~ qss(s, lambda = 3), tau = 0.9, data = player_runs)
#     s_seq <- seq(min(player_runs$s, na.rm = TRUE), max(player_runs$s, na.rm = TRUE), length.out = 100)
#     pred_df <- tibble(s = s_seq)
#     pred_df$a <- predict(rq_fit, newdata = pred_df)
# 
#     # Interactive ggplot
#     p <- ggplot() +
#       geom_point(data = player_runs, aes(
#       x = s, 
#       y = a,
#       text = paste0("Speed: ", round(s, 2),
#                     "<br>Acceleration: ", round(a, 2))), 
#       alpha = 0.5, 
#       color = "grey40") +
#       geom_line(data = pred_df, aes(x = s, y = a), 
#                 color = "blue", size = 1.2) +
#       scale_x_continuous(name = "Speed") +
#       scale_y_continuous(name = "Acceleration") +
#       labs(
#         title = paste0(name, "'s Effort Quantile Curve (90%)"),
#         caption = "Data from Weeks 1–9 of the 2022 NFL Season"
#       ) +
#       theme_minimal() +
#       theme(
#         plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
#         axis.title = element_text(face = "bold", size = 14),
#         axis.text = element_text(size = 12),
#         plot.caption = element_text(face = "italic", size = 9)
#       )
# 
#     return(ggplotly(p, tooltip = "text"))
#   }
# 
#   return(tibble(displayName = name, effort_ratio_90 = 1 - eff_score))
# }
# 
# 
#  (eff_function_rqss("Saquon Barkley", graph = TRUE))

```


### Tab 2: Rex Burkhead
```{r}
##| label: fig-quant-2
##| fig-cap: "trying out non-linear-quant-regression"

# 
# 
# set.seed(1)
# 
# eff_function_rqss <- function(name, graph = FALSE) {
#   player_runs <- tracking_bc |> 
#     filter(displayName == name)
# 
#   N_FOLDS <- 5
#   player_runs_modeling <- player_runs |> 
#     select(s, a) |> 
#     mutate(fold = sample(rep(1:N_FOLDS, length.out = n())))
#   
#   player_runs_cv <- function(x) {
#     test_data <- player_runs_modeling |> 
#       filter(fold == x)
#     train_data <- player_runs_modeling |> 
#       filter(fold != x)
#     
#     s_range <- range(train_data$s)
#     test_data <- test_data |> 
#       filter(s >= max(s_range[1], 1),
#              s <= min(s_range[2], 9))
#     
#     rq_fit <- rqss(a ~ qss(s, lambda = 3), tau = 0.9, data = train_data)
#     
#     out <- tibble(
#       rq_pred = predict(rq_fit, newdata = test_data),
#       test_actual = test_data$a,
#       res_rq = test_actual - rq_pred,
#       test_fold = x
#     )
#     return(out)
#   }
# 
#   player_runs_test_preds <- map(1:N_FOLDS, player_runs_cv) |> 
#     list_rbind()
#   
#   eff_score <- mean(player_runs_test_preds$res_rq < 0)
# 
#   if (graph == TRUE) {
#     # Fit final model and compute smooth prediction line
#     rq_fit <- rqss(a ~ qss(s, lambda = 3), tau = 0.9, data = player_runs)
#     s_seq <- seq(min(player_runs$s, na.rm = TRUE), max(player_runs$s, na.rm = TRUE), length.out = 100)
#     pred_df <- tibble(s = s_seq)
#     pred_df$a <- predict(rq_fit, newdata = pred_df)
# 
#     # Interactive ggplot
#     p <- ggplot() +
#       geom_point(data = player_runs, aes(
#       x = s, 
#       y = a,
#       text = paste0("Speed: ", round(s, 2),
#                     "<br>Acceleration: ", round(a, 2))), 
#       alpha = 0.5, 
#       color = "grey40") +
#       geom_line(data = pred_df, aes(x = s, y = a), 
#                 color = "blue", size = 1.2) +
#       scale_x_continuous(name = "Speed") +
#       scale_y_continuous(name = "Acceleration") +
#       labs(
#         title = paste0(name, "'s Effort Quantile Curve (90%)"),
#         caption = "Data from Weeks 1–9 of the 2022 NFL Season"
#       ) +
#       theme_minimal() +
#       theme(
#         plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
#         axis.title = element_text(face = "bold", size = 14),
#         axis.text = element_text(size = 12),
#         plot.caption = element_text(face = "italic", size = 9)
#       )
# 
#     return(ggplotly(p, tooltip = "text"))
#   }
# 
#   return(tibble(displayName = name, effort_ratio_90 = 1 - eff_score))
# }
# 
# 
#  (eff_function_rqss("Rex Burkhead", graph = TRUE))

```
:::


## Acknowledgements

- Used Dr. Ron Yurko and Quang Nguyen's code to calculate distance from the nearest defender [@qntkhvnAngle]












