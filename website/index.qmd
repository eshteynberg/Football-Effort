---
title: "Tracking the Intangible: Quantifying Effort in NFL Running Backs"
author:
- "Emily Shteynberg"
- "Luke Snavely"
- "Sheryl Solorzano"
date: "July 25, 2025"
toc: true
format:
  html:
    theme: cosmo
    html-math-method: katex
    self-contained: true
execute:
  echo: false
  warning: false
  message: false
bibliography: bib/library.bib
---

```{r}
#| label: setup
#| include: false

# Load necessary packages
library(tidyverse)
library(knitr)
library(ggplot2)
library(plotly)
library(tidytext)
library(quantreg)

```

```{r}
#| fig-width: 8
#| fig-height: 4
#| out.width: "85%"
#| fig-align: "center"


include_graphics("docs/images/NFL2022.png")

```

*Image source: [The Tower](https://sbadamsthetower.com/7756/sports/2022-2023-nfl-preview/)*




---

## Introduction 

Describe the problem and why it is important.

American Football is one of the most-watched and popular sports in the U.S., known for its quick decision-making, complex tactics, and athletically demanding displays of strength, endurance and speed.  


## Data

- Describe the data you’re using in detail, where you accessed it, along with relevant exploratory data analysis (EDA). You should also include descriptions of any relevant data pre-processing steps (e.g., whether you consider specific observations, create any meaningful features, etc.---but don't mention minor steps like column type conversion, filtering out unnecessary rows)

- The data used for this project were from NFL Big Data Bowl 2022 Dataset [@nfl2022] on Kaggle.

 - We limited our dataset to NFL running backs with more than 20 rushes.

## Methods

- Describe the modeling techniques you chose, their assumptions, justifications for why they are appropriate for the problem, and how you're comparing/evaluating the different methods.

- Used Dr. Ron Yurko and Quang Nguyen's code to calculate distance from the nearest defender [@qntkhvnAngle]

- Based our AS/ AKE curved on the article titled "Individual acceleration-speed profile in-situ: A proof of concept in professional football players"[@AS]

- Still using the non-linear quantile regression plot? [@quantReg]


## Results

Describe your results. This can include tables and plots showing your results, as well as text describing how your models worked and the appropriate interpretations of the relevant output. (Note: Don’t just write out the textbook interpretations of all model coefficients. Instead, interpret the output that is relevant for your question of interest that is framed in the introduction)

## Discussion

Give your conclusions and summarize what you have learned with regards to your question of interest. Are there any limitations with the approaches you used? What do you think are the next steps to follow-up your project?

## Appendix

```{r}
#| label: non-linear-quant-regression
#| fig-cap: "Non-linear quantile regression for acceleration vs speed"

load("web_data/tracking_bc.Rdata")
load("web_data/player_runs_modeling.Rdata")


set.seed(1)

eff_function_rqss <- function(name, graph = FALSE) {
  player_runs <- tracking_bc |> 
    filter(displayName == name)

  N_FOLDS <- 5
  player_runs_modeling <- player_runs |> 
    select(s, a) |> 
    mutate(fold = sample(rep(1:N_FOLDS, length.out = n())))
  
  player_runs_cv <- function(x) {
    test_data <- player_runs_modeling |> 
      filter(fold == x)
    train_data <- player_runs_modeling |> 
      filter(fold != x)
    
    s_range <- range(train_data$s)
    test_data <- test_data |> 
      filter(s >= max(s_range[1], 1),
             s <= min(s_range[2], 9))
    
    rq_fit <- rqss(a ~ qss(s, lambda = 3), tau = 0.9, data = train_data)
    
    out <- tibble(
      rq_pred = predict(rq_fit, newdata = test_data),
      test_actual = test_data$a,
      res_rq = test_actual - rq_pred,
      test_fold = x
    )
    return(out)
  }

  player_runs_test_preds <- map(1:N_FOLDS, player_runs_cv) |> 
    list_rbind()
  
  eff_score <- mean(player_runs_test_preds$res_rq < 0)

  if (graph == TRUE) {
    # Fit final model and compute smooth prediction line
    rq_fit <- rqss(a ~ qss(s, lambda = 3), tau = 0.9, data = player_runs)
    s_seq <- seq(min(player_runs$s, na.rm = TRUE), max(player_runs$s, na.rm = TRUE), length.out = 100)
    pred_df <- tibble(s = s_seq)
    pred_df$a <- predict(rq_fit, newdata = pred_df)

    # Interactive ggplot
    p <- ggplot() +
      geom_point(data = player_runs, aes(
      x = s, 
      y = a,
      text = paste0("Speed: ", round(s, 2),
                    "<br>Acceleration: ", round(a, 2))), 
      alpha = 0.5, 
      color = "grey40") +
      geom_line(data = pred_df, aes(x = s, y = a), 
                color = "blue", size = 1.2) +
      scale_x_continuous(name = "Speed") +
      scale_y_continuous(name = "Acceleration") +
      labs(
        title = paste0(name, "'s Effort Quantile Curve (90%)"),
        caption = "Data from Weeks 1–9 of the 2022 NFL Season"
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
        axis.title = element_text(face = "bold", size = 14),
        axis.text = element_text(size = 12),
        plot.caption = element_text(face = "italic", size = 9)
      )

    return(ggplotly(p, tooltip = "text"))
  }

  return(tibble(displayName = name, effort_ratio_90 = 1 - eff_score))
}

g1 <- ggplotly(eff_function_rqss("Saquon Barkley", graph = TRUE))
g2 <- ggplotly(eff_function_rqss("Rex Burkhead", graph = TRUE))



# Step 2: Initialize plotly figure
fig <- plot_ly()

# Step 3: Add Saquon traces (visible)
for (trace in g1$x$data) {
  trace$visible <- TRUE
  fig <- fig %>% add_trace(
    x = trace$x,
    y = trace$y,
    type = trace$type,
    mode = trace$mode,
    line = trace$line,
    name = trace$name,
    text = trace$text,
    hoverinfo = trace$hoverinfo,
    visible = TRUE
  )
}

# Step 4: Add Rex traces (initially hidden)
for (trace in g2$x$data) {
  trace$visible <- FALSE
  fig <- fig %>% add_trace(
    x = trace$x,
    y = trace$y,
    type = trace$type,
    mode = trace$mode,
    line = trace$line,
    name = trace$name,
    text = trace$text,
    hoverinfo = trace$hoverinfo,
    visible = FALSE
  )
}

# Step 5: Construct correct visibility vectors
n1 <- length(g1$x$data)
n2 <- length(g2$x$data)

vis_saquon <- c(rep(TRUE, n1), rep(FALSE, n2))
vis_rex    <- c(rep(FALSE, n1), rep(TRUE, n2))

# Step 6: Add dropdown menu with correct visibility toggles
fig <- fig %>% layout(
  title = "Acceleration vs Speed Curve by Player",
  updatemenus = list(
    list(
      type = "dropdown",
      y = 0.8,
      x = 1.1,
      buttons = list(
        list(method = "restyle",
             args = list("visible", vis_saquon),
             label = "Saquon Barkley"),
        list(method = "restyle",
             args = list("visible", vis_rex),
             label = "Rex Burkhead")
      )
    )
  )
)

fig

```



## Appendix: A quick tutorial

**(Feel free to remove this section when you submit)**

This a Quarto document. 
To learn more about Quarto see <https://quarto.org>.
You can use the Render button to see what it looks like in HTML.

### Text formatting

Text can be bolded with **double asterisks** and italicized with *single asterisks*. 
Monospace text, such as for short code snippets, uses `backticks`.
(Note these are different from quotation marks or apostrophes.) Links are
written [like this](http://example.com/).

Bulleted lists can be written with asterisks:

* Each item starts on a new line with an asterisk.
* Items should start on the beginning of the line.
* Leave blank lines after the end of the list so the list does not continue.

Mathematics can be written with LaTeX syntax using dollar signs. 
For instance, using single dollar signs we can write inline math: $(-b \pm \sqrt{b^2 - 4ac})/2a$.

To write math in "display style", i.e. displayed on its own line centered on the
page, we use double dollar signs:
$$
x^2 + y^2 = 1
$$


### Code blocks

Code blocks are evaluated sequentially when you hit Render. 
As the code runs, `R` prints out which block is running, so naming blocks is useful if you want to know which one takes a long time. 
After the block name, you can specify [chunk options](https://yihui.org/knitr/options/). 
For example, `echo` controls whether the code is printed in the document. 
By default, output is printed in the document in monospace:

```{r, echo = FALSE}
head(mtcars)
```

Chunk options can also be written inside the code block, which is helpful for really long options, as we'll see soon.

```{r}
#| echo: false
head(mtcars)
```

### Figures

If a code block produces a plot or figure, this figure will automatically be inserted inline in the report. That is, it will be inserted exactly where the code block is.

```{r}
#| fig-width: 5
#| fig-height: 3.5
#| fig-cap: "This is a caption. It should explain what's in the figure and what's interesting about it. For instance: There is a negative, strong linear correlation between miles per gallon and horsepower for US cars in the 1970s."

library(tidyverse)
mtcars |> 
  ggplot(aes(x = mpg, y = hp)) +
  geom_point() +
  labs(x = "Miles per gallon",
       y = "Horsepower")
```

Notice the use of `fig-width` and `fig-height` to control the figure's size (in inches). 
These control the sizes given to `R` when it generates the plot, so `R` proportionally adjusts the font sizes to be large enough.

### Tables

Use the `knitr::kable()` function to print tables as HTML:

```{r}
mtcars |> 
  slice(1:5) |> 
  knitr::kable()
```

We can summarize model results with a table. 
For instance, suppose we fit a linear regression model:

```{r}
#| echo: true
model1 <- lm(mpg ~ disp + hp + drat, data = mtcars)
```

It is *not* appropriate to simply print `summary(model1)` into the report. 
If we want the reader to understand what models we have fit and what their results are, we should provide a nicely formatted table. 
A simple option is to use the `tidy()` function from the `broom` package to get a data frame of the model fit, and simply report that as a table.

```{r }
#| results: "asis"
#| tbl-cap: "Predicting fuel economy using vehicle features."
library(broom)
model1 |> 
  tidy() |>
  knitr::kable(digits = 2,
               col.names = c("Term", "Estimate", "SE", "t", "p"))
```