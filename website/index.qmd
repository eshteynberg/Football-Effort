---
title: "Tracking the Intangible: Quantifying Effort in NFL Running Backs"
author:
- "Emily Shteynberg"
- "Luke Snavely"
- "Sheryl Solorzano"
date: "July 25, 2025"
format:
  html:
    html-math-method: katex
    self-contained: true
execute:
  echo: false
  warning: false
  message: false
bibliography: bib/library.bib
---

```{r}
#| label: setup
#| include: false

# Load necessary packages
library(tidyverse)
library(knitr)
library(ggplot2)
library(plotly)
library(tidytext)
library(quantreg)
library(qgam)
library(knitr)
library(kableExtra)
library(gridExtra)
library(patchwork)

```


---

## Introduction 

While athletes are often praised for “giving 100%,” what that entails remains poorly defined and difficult to measure objectively. Unlike physical traits such as endurance, strength, and agility, effort is intangible and often conflated with performance outcomes or inferred through subjective observation. Nevertheless, it is widely regarded as a crucial factor in athletic success, influencing both perceived competitiveness and in-game results. Developing a reliable, standardized method to evaluate effort could offer new insight into player capabilities and decision-making.

This study focuses on running backs (RBs) in the NFL, a position characterized by short, high-intensity bursts of movement within clearly structured offensive plays. The nature of their role—frequent accelerations and heavy physical contact—makes RBs a suitable candidate for analyzing exertion in a relatively controlled and consistent context.

Our approach builds on prior work deriving professional soccer players’ theoretical maximum acceleration capacity as a function of running speed in-situ.^1^ To date, no comparable methodology has been applied to American football. By adapting it to RBs, we aim to isolate the measurable, movement-based component of effort, independent of tactical decisions or situational context.

The objective of this study is twofold: (1) to improve estimation of individual acceleration-speed (A-S) profiles using tracking data, and (2) to assess how frequently players operate near or exceed these limits as a proxy for effort.


## Data

The data were obtained from the NFL Big Data Bowl 2025, an annual league-sponsored analytics competition that provides game, play, player, and tracking data recorded at 10 frames per second.^2^ The dataset covers weeks 1-9 of the 2022 NFL season, comprising 136 games.

### Pre-processing: 

* Using the tracking data, we first standardized players’ positional coordinates and orientations such that all plays move from left to right, with the bottom-left corner of the field set as the “origin.”

* After merging the data, we filtered for running plays where the RB was the ball carrier and restricted the sample to RBs with at least 20 rushing attempts, yielding 69 players. Each observation corresponds to a single frame of tracking data.


### Feature engineering:

* The tracking data provided only the magnitude of acceleration. To be able to differentiate between positive acceleration and negative acceleration (deceleration), we derived a variable for *directional* acceleration by multiplying the given magnitude of acceleration by the cosine of the angle of player motion. 

* We converted speed and directional acceleration to miles per hour (mph) and miles per hour per second (mph/s), respectively.

* We created several frame-level variables, all measured at the time of handoff, for use in our validation model *(see Methods)* as follows:

  * **Distance to nearest defender**: compute the Euclidean distance between the RB’s and each defender’s positional coordinates; select the minimum distance 

  * **Number of defenders within 5 yards of the RB**: count the number of defenders whose Euclidean distance to the RB is less than or equal to 5 yards 

  * **Number of blockers in front of the RB**: the number of blockers (defined as offensive linemen or fullbacks) whose x-coordinates exceed that of the RBs


## Methods

### Motivation

Our initial approach was adapted from the aforementioned prior research building individual A-S profiles of soccer players.^1^ For each RB, we plot the frame-level A-S profile based on the maximal acceleration they could generate for every possible running speed using the *Morin et al., 2021* procedure as follows:


Within a speed interval ranging between 3 mph and the RB’s maximal speed, the two maximal acceleration values attained for each 0.2 mph subinterval were selected. A first linear regression was fitted to these speed-acceleration points. Outlier points lying outside of the 95% confidence interval around the linear function were removed. A final linear regression was fitted to the remaining points, defining what we refer to as the “maximum acceleration frontier.”

> <span style="color: black; font-style: normal;">
> To compute “effort” from the A-S profile, the regression line was first shifted downward by 0.25 units (determined via sensitivity analysis) to include points sufficiently close to the estimated frontier. Effort was then defined as the percentage of a player’s points that fell above this relaxed threshold.
> </span>

However, this approach has several limitations. First, it excludes points with speeds below 3 mph from the linear regression model, effectively disregarding low-speed frames—even though effort may still be exerted at lower velocities. Second, the model extrapolates beyond the observed data, leading to unrealistic estimates of theoretical maximum speeds. Third, players with greater athletic ability may be disproportionately penalized. Because the frontier is estimated relative to each player’s own maximal accelerations, players with a greater physical capacity must reach a higher threshold for their frames to be classified as effortful. Finally, the model does not differentiate between acceleration and deceleration; all changes in velocity are treated equally, despite our belief that deceleration requires less effort than acceleration, as it typically demands less metabolic power.^3^

::: {.panel-tabset}
### Theoretical Max Acceleration (A~0~)

![](photos/A_0_graph.png){width=80%}

### Theoretical Max Speed (S~0~)

![](photos/S_0_graph.png){width=80%}
:::

### Metric #1: Quadratic Quantile Regression

To address the shortcomings of the linear regression approach, we developed an effort metric based on quadratic quantile regression. This method was selected for two reasons. First, the relationship between acceleration and speed is empirically nonlinear. Second, quantile regression enables an estimation of the upper envelope of a player’s acceleration distribution. Unlike ordinary least squares techniques (e.g., linear regression), which estimate the conditional mean, quantile regression is more appropriate for identifying players’ maximum acceleration capacities. Specifically, the 0.95 quantile (i.e., the 95th percentile) was used to represent each player’s maximum acceleration frontier, capturing some of their highest observed exertions while minimizing the impact of outliers. For example, extreme, one-off accelerations in the 0.99 quantile might distort the frontier.

For every RB, we again examine the joint distribution of frame-level speed and acceleration. We fit two quadratic quantile regressions to estimate the 0.95 quantiles of acceleration and deceleration, respectively, as functions of speed. Each model was trained on all available frames for a given player. The resulting curves define the individual maximum acceleration frontiers: one for acceleration and another for deceleration.  

We compute effort as follows: first, calculate the vertical distance $d_i$ from each point to the frontier corresponding to its acceleration sign, setting $d_i=0$ for points on or past the curve. Each frame is assigned a score according to 

$$
\Psi_i = \begin{cases}
  \frac{1}{1+d_i} & a_i\geq 0 \\
  \frac{1}{2}\cdot\frac{1}{1+d_i} & a_i<0,
    \end{cases}
$$
where $a_i$ denotes the point’s acceleration.

Points with negative acceleration are penalized by a factor of 0.5, reflecting prior findings that deceleration is 2-4 times less metabolically demanding than acceleration.^3^ We thus consider deceleration less effortful. 

Finally, average effort for each player is computed as the mean of their frame-level scores:

$$
\text{Effort} = \frac{\sum_{i=1}^n \Psi}{n}
$$

::: {.panel-tabset}

### Tab 1: Saquon Barkley  (QGAM)
```{r}
#| label: effort-metric-two
#| fig-cap: "....."
#| message: false
#| warning: false
#| cache: true

load("web_data/tracking_bc2.Rdata")
load("web_data/player_runs_modeling.Rdata")

eff_function_nlrq <- function(name, graph = FALSE) {
  # Choosing player name
  player_runs <- tracking_bc |> 
    filter(displayName == name)
  
  # Making the modeling data frame
  player_runs_modeling <- player_runs |> 
    select(s_mph, dir_a_mpsh, gameId, displayName, bc_id, playId, frameId)
  
  # Data to be in model
  data_pos <- player_runs_modeling |> 
    filter(dir_a_mpsh >= 0)
  
  data_neg <- player_runs_modeling |> 
    filter(dir_a_mpsh < 0)
  
  # Models
  nlrq_pos <- nlrq(dir_a_mpsh ~ x * s_mph^2 + y * s_mph + z,
                   data = data_pos,
                   tau = .95,
                   start = list(x = 10, y = 2, z = 5))

  nlrq_neg <- nlrq(dir_a_mpsh ~ x * s_mph^2 + y * s_mph + z,
                   data = data_neg,
                   tau = .05,
                   start = list(x = 10, y = 2, z = 5))
  
  data_pos_final <- data_pos |> 
    mutate(nlrq_pred = nlrq_pos$m$fitted(),
           diff_a = nlrq_pred - dir_a_mpsh)
  
  data_neg_final <- data_neg |> 
    mutate(nlrq_pred = nlrq_neg$m$fitted(),
           diff_a = dir_a_mpsh - nlrq_pred)
  
  
  # Combining positive and negative vals
  player_runs_test_preds <- rbind(data_pos_final, data_neg_final)
  
  if (graph == TRUE) {
    out_line <- player_runs_test_preds |> 
      filter(diff_a <= 0)
    
    player_graph <- player_runs_test_preds |> 
      ggplot(aes(x = s_mph, y = dir_a_mpsh)) +
      geom_point(alpha=.6, color="grey2")+
      geom_point(data = out_line, aes(x = s_mph, y = dir_a_mpsh, fill = "Adjusted distance = 0"), size = 4, 
                 stroke = 1.2, color="black", shape = 21) +
      geom_line(data = data_pos_final, aes(y = nlrq_pred, color = "0.95 quantile accel. \nregression line"), lwd = 1.2) +
      geom_line(data = data_neg_final, aes(y = nlrq_pred, color = "0.95 quantile decel. \nregression line"), lwd = 1.2) +
      geom_hline(aes(yintercept = 0), color = "black", lwd = 1.2, lty = 2) +
      scale_color_manual("Line", values = c("#D55E00", "#0072B2", "goldenrod")) +
      scale_fill_manual("Point", values = c("#b3b3b3")) +
      labs(x = "Speed (mph)",
           y = "Acceleration (mph/s)",
           title = paste0(name, "'s effort score: 18.65%")) +
      theme_minimal(base_size=16) +
      theme(plot.title = element_text(face = "bold.italic",
                                      size = 18, 
                                      hjust = .5),
            legend.title = element_text(face = "bold"),
            axis.title = element_text(face = "bold"),
            legend.text=element_text(size=15),
            plot.caption = element_text(face = "italic", size = 8),
            legend.key.height = unit(1.4, "cm"),
            legend.position = "right") +
      xlim(0, 25) +
      ylim(-15, 15)
    return(player_graph)
  }
  return(player_runs_test_preds)
}
eff_function_nlrq("Saquon Barkley", graph = TRUE)


nlrq_combined <- purrr::map(rbs_names, eff_function_nlrq) |>
  bind_rows()

nlrq_dis <- nlrq_combined |> 
  mutate(diff_adj = ifelse(diff_a <= 0, 0, diff_a),
         dis_score = 1 / (1 + diff_adj),
         dis_score_adj = ifelse(dir_a_mpsh < 0, dis_score / 2, dis_score))

# Play level
nlrq_dis_play <- nlrq_dis |> 
  group_by(gameId, playId, bc_id, displayName) |> 
  summarize(dis_score = mean(dis_score_adj)) |> 
  ungroup()

# Player level
nlrq_dis_player <- nlrq_dis |> 
  group_by(bc_id, displayName) |> 
  summarize(dis_score = mean(dis_score_adj)) |> 
  ungroup() |> 
  arrange(desc(dis_score)) |> 
  mutate(dis_score = round(dis_score, 4) *100,
         rank = 1:n())

```


### Tab 2: James Cook

```{r}
#| label: james-cook
#| fig-cap: "....."
#| message: false
#| warning: false
#| cache: true

load("web_data/tracking_bc2.Rdata")
load("web_data/player_runs_modeling.Rdata")

eff_function_nlrq <- function(name, graph = FALSE) {
  # Choosing player name
  player_runs <- tracking_bc |> 
    filter(displayName == name)
  
  # Making the modeling data frame
  player_runs_modeling <- player_runs |> 
    select(s_mph, dir_a_mpsh, gameId, displayName, bc_id, playId, frameId)
  
  # Data to be in model
  data_pos <- player_runs_modeling |> 
    filter(dir_a_mpsh >= 0)
  
  data_neg <- player_runs_modeling |> 
    filter(dir_a_mpsh < 0)
  
  # Models
  nlrq_pos <- nlrq(dir_a_mpsh ~ x * s_mph^2 + y * s_mph + z,
                   data = data_pos,
                   tau = .95,
                   start = list(x = 10, y = 2, z = 5))

  nlrq_neg <- nlrq(dir_a_mpsh ~ x * s_mph^2 + y * s_mph + z,
                   data = data_neg,
                   tau = .05,
                   start = list(x = 10, y = 2, z = 5))
  
  data_pos_final <- data_pos |> 
    mutate(nlrq_pred = nlrq_pos$m$fitted(),
           diff_a = nlrq_pred - dir_a_mpsh)
  
  data_neg_final <- data_neg |> 
    mutate(nlrq_pred = nlrq_neg$m$fitted(),
           diff_a = dir_a_mpsh - nlrq_pred)
  
  
  # Combining positive and negative vals
  player_runs_test_preds <- rbind(data_pos_final, data_neg_final)
  
  if (graph == TRUE) {
    out_line <- player_runs_test_preds |> 
      filter(diff_a <= 0)
    
    player_graph <- player_runs_test_preds |> 
      ggplot(aes(x = s_mph, y = dir_a_mpsh)) +
      geom_point(alpha=.6, color="grey2")+
      geom_point(data = out_line, aes(x = s_mph, y = dir_a_mpsh, fill = "Adjusted distance = 0"), size = 4, 
                 stroke = 1.2, color="black", shape = 21) +
      geom_line(data = data_pos_final, aes(y = nlrq_pred, color = "0.95 quantile accel. \nregression line"), lwd = 1.2) +
      geom_line(data = data_neg_final, aes(y = nlrq_pred, color = "0.95 quantile decel. \nregression line"), lwd = 1.2) +
      geom_hline(aes(yintercept = 0), color = "black", lwd = 1.2, lty = 2) +
      scale_color_manual("Line", values = c("#D55E00", "#0072B2", "goldenrod")) +
      scale_fill_manual("Point", values = c("#b3b3b3")) +
      labs(x = "Speed (mph)",
           y = "Acceleration (mph/s)",
           title = paste0(name, "'s effort score: 22.60%")) +
      theme_minimal(base_size=16) +
      theme(plot.title = element_text(face = "bold.italic",
                                      size = 18, 
                                      hjust = .5),
            legend.title = element_text(face = "bold"),
            axis.title = element_text(face = "bold"),
            legend.text=element_text(size=15),
            plot.caption = element_text(face = "italic", size = 8),
            legend.key.height = unit(1.4, "cm"),
            legend.position = "right") +
      xlim(0, 25) +
      ylim(-15, 15)
    return(player_graph)
  }
  return(player_runs_test_preds)
}


eff_function_nlrq("James Cook", graph = TRUE)
```
:::




### Metric #2: Quantile Generalized Additive Model (QGAM)

As an alternative to the fixed-form quadratic quantile regression, we implemented a QGAM to allow greater flexibility in estimating the individual maximum acceleration frontier. A GAM is particularly well-suited to our context, as the true A-S profile may vary in form across players and is unlikely to consistently follow a simple quadratic curve. We continued to use the 0.95 quantile to capture near-maximal acceleration while mitigating sensitivity to outliers.

For each RB, we fit two QGAMs with adaptive spline bases to the 0.95 quantiles of acceleration and deceleration, respectively, as functions of speed. The resulting curves again define the individualized frontiers for acceleration and deceleration. Average frame-level effort is then computed according to the same procedure as for Metric #1 above.


   

```{r}
#| label: effort-metric-one
#| fig-cap: "......"
#| message: false
#| warning: false
#| cache: true

load("web_data/tracking_bc2.Rdata")
load("web_data/player_runs_modeling.Rdata")
load("web_data/rbs_names.Rdata")

# qgam right --------------------------------------------------------------

eff_function_qgam <- function(name, graph = FALSE) {
  # Choosing player name
  player_runs <- tracking_bc |> 
    filter(displayName == name)
  
  # Modeling dataframe
  player_runs_modeling <- player_runs |> 
    select(s_mph, dir_a_mpsh, gameId, displayName, bc_id, playId, frameId)
  
  # Split positive and negative acceleration
  data_pos <- player_runs_modeling |> filter(dir_a_mpsh >= 0)
  data_neg <- player_runs_modeling |> filter(dir_a_mpsh < 0)

  # Fit qgam models
  suppressMessages({
    suppressWarnings({
      capture.output({
        qgam_fit_a_top <- qgam(dir_a_mpsh ~ s(s_mph, k = 10, bs = "ad"),
                               data = data_pos, qu = .95,
                               multicore = TRUE, ncores = 7)
      })
    })
  })

  suppressMessages({
    suppressWarnings({
      capture.output({
        qgam_fit_a_bottom <- qgam(dir_a_mpsh ~ s(s_mph, k = 10, bs = "ad"),
                                  data = data_neg, qu = .05,
                                  multicore = TRUE, ncores = 7)
      })
    })
  })

  # Add predicted values
  data_pos_final <- data_pos |> 
    mutate(qgam_pred = qgam_fit_a_top$fitted.values,
           diff_a = qgam_pred - dir_a_mpsh)

  data_neg_final <- data_neg |> 
    mutate(qgam_pred = qgam_fit_a_bottom$fitted.values,
           diff_a = dir_a_mpsh - qgam_pred)

  # Combine
  player_runs_test_preds <- bind_rows(data_pos_final, data_neg_final)

  if (graph == TRUE) {
    out_line <- player_runs_test_preds |> filter(diff_a <= 0)

    # Base ggplot with custom tooltip
    p <- ggplot(player_runs_test_preds, aes(x = s_mph, y = dir_a_mpsh)) +
      geom_point(aes(
        text = paste0("Speed: ", round(s_mph, 2),
                      "<br>Acceleration: ", round(dir_a_mpsh, 2))),
        alpha = 0.6, color = "grey2") +
      geom_point(data = out_line, aes(
        text = paste0("Speed: ", round(s_mph, 2),
                      "<br>Acceleration: ", round(dir_a_mpsh, 2))),
        fill = "#b3b3b3", color = "black", stroke = 1.2, shape = 21, size = 4) +
      geom_line(data = data_pos_final, aes(y = qgam_pred, color = "0.95 quantile accel. \nregression line"), lwd = 1.2) +
      geom_line(data = data_neg_final, aes(y = qgam_pred, color = "0.95 quantile decel. \nregression line"), lwd = 1.2) +
      geom_hline(aes(yintercept = 0), color = "black", lwd = 1.2, lty = 2) +
      scale_color_manual("Line", values = c("#D55E00", "#0072B2")) +
      labs(
        x = "Speed (mph)",
        y = "Acceleration (mph/s)",
        title = paste0(name, "'s Effort Quantile (95%)")
      ) +
      theme_minimal(base_size = 16) +
      theme(
        plot.title = element_text(face = "bold.italic", size = 18, hjust = .5),
        legend.title = element_text(face = "bold"),
        axis.title = element_text(face = "bold"),
        legend.text = element_text(size = 15),
        plot.caption = element_text(face = "italic", size = 8),
        legend.key.height = unit(1.4, "cm")
      ) +
      xlim(0, 25) +
      ylim(-15, 15)

    # Convert to plotly
    return(ggplotly(p, tooltip = "text"))
  }

  return(player_runs_test_preds)
}



#eff_function_qgam("James Cook", graph = TRUE)




# qgam_combined <- purrr::map(rbs_names, eff_function_qgam) |>
#   bind_rows()
# 
# qgam_dis <- qgam_combined |> 
#   mutate(diff_adj = ifelse(diff_a <= 0, 0, diff_a),
#          dis_score = 1 / (1 + diff_adj),
#          dis_score_adj = ifelse(dir_a_mpsh < 0, dis_score / 2, dis_score))
# 
# # Play level
# qgam_dis_play <- qgam_dis |> 
#   group_by(gameId, playId, bc_id, displayName) |> 
#   summarize(dis_score = mean(dis_score_adj)) |> 
#   ungroup()
# 
# # Player level
# qgam_dis_player <- qgam_dis |> 
#   group_by(bc_id, displayName) |> 
#   summarize(dis_score = mean(dis_score_adj)) |> 
#   ungroup() |> 
#   arrange(desc(dis_score)) |> 
#   mutate(dis_score = round(dis_score, 4) *100,
#          rank = 1:n())


```

```{r}
#| label: second-metric
#| fig-cap: "testing out a few players"
#| message: false
#| warning: false
#| cache: true

# Player list
rb_dd_menu <- c("Chase Edmonds", "Rachaad White", "D'Andre Swift", 
                "Samaje Perine", "Joshua Kelley", "Matt Breida", "Alexander Mattison",
                "Josh Jacobs", "James Cook", "Melvin Gordon")

# Initialize plot
fig5 <- plot_ly()
all_traces <- list()
visibility_masks <- list()
trace_lengths <- c()

#Loop through each running back to collect their traces
for (i in seq_along(rb_dd_menu)) {
  player <- rb_dd_menu[i]
  plot_obj <- ggplotly(eff_function_qgam(player, graph = TRUE))
  
  player_traces <- list()
  for (trace in plot_obj$x$data) {
    if (trace$mode == "markers") {
    }
    trace$visible <- (i == 1) 
    
    # this is to display the first running back's AS quantile regression 
    fig5 <- fig5 |> add_trace(
      x = trace$x,
      y = trace$y,
      type = trace$type,
      mode = trace$mode,
      line = trace$line,
      marker = if (!is.null(trace$marker$color)) trace$marker else NULL,
      name = trace$name,
      text = trace$text,
      hoverinfo = trace$hoverinfo,
      visible = trace$visible
    )
    player_traces <- append(player_traces, list(trace))
  }
  
  all_traces[[i]] <- player_traces
  trace_lengths[i] <- length(player_traces)
}

#  Visibility masks for dropdown
total_traces <- sum(trace_lengths)

for (i in seq_along(rb_dd_menu)) {
  mask <- rep(FALSE, total_traces)
  start_index <- sum(trace_lengths[1:(i - 1)]) + 1
  end_index <- sum(trace_lengths[1:i])
  mask[start_index:end_index] <- TRUE
  visibility_masks[[i]] <- mask
}

# Adding dropdown menu
dropdown_buttons <- lapply(seq_along(rb_dd_menu), function(i) {
  list(
    method = "update",  # update both trace visibility and layout
    args = list(
      list(visible = visibility_masks[[i]]),  # traces to show
      list(title = list(text = paste0(rb_dd_menu[i], "'s Effort Quantile (95%)")))  # title change
    ),
    label = rb_dd_menu[i]
  )
})

fig5 <- fig5 |>
  layout(
    title = list(text = paste0(rb_dd_menu[1], "'s Effort Quantile (95%)")), 
    yaxis = list(title = "Acceleration (mph/s)"),
    xaxis = list(title = "Speed (mph)"),
    updatemenus = list(
      list(
        type = "dropdown",
        y = 0.6,
        x = 1.3,
        buttons = dropdown_buttons
      )
    )
  )
fig5


```



### Validation Model

To evaluate the predictive power of our effort metrics, we developed an Expected Points Added (EPA) over expected model. EPA is derived from Expected Points (EP), which estimates the number of points a team is likely to score on a drive based on the current game context. EPA is calculated as the difference between EP before and after a play, providing a measure of its contribution to a team’s scoring potential. 

EPA was selected as the outcome variable because it reflects the effectiveness of a play in terms of point value. To assess whether effort explains meaningful variance in play success, we computed correlations between model residuals and our effort metrics. A significant correlation would suggest that effort captures information not already explained by standard pre-play features. 

The model uses only variables available at the time of handoff to the RB. Including features from later in the play would introduce data leakage, since EPA is calculated only after the play is complete. Predictor variables include:

::: {.columns}
::: {.column width="50%"}
#### **Game context**
* Home field advantage
* Quarter
* Down
* Score differential

#### **Play context**
* Yards to go to a first down
* Yards to go to the endzone
* Number of blockers in front of the RB
* Number of defenders within 5 yards of the RB
* Offensive formation
* Run concept

:::

::: {.column width="50%"}

#### **RB characteristics**
* Speed
* Directional acceleration
* Weight
* Positional coordinates of RB on field

#### **Nearest defender characteristics**
* Speed
* Directional acceleration
* Angle with the RB
* Distance to RB

:::
:::


We used a random forest model for its ability to capture nonlinear relationships and reduce the risk of overfitting. We performed 5-fold cross validation, assigning entire games to individual folds to mitigate possible dependencies.

## Results

Our findings indicate that backup RBs consistently exhibit higher frame-level effort across both metrics compared to starters. This may reflect a tendency to capitalize on limited playing time by more frequently approaching or exceeding their individual maximum acceleration frontiers. Playing fewer snaps also likely reduces cumulative fatigue, enabling backups to sustain higher-effort movements when on the field. Conversely, starters may possess greater innate talent, physical ability, or experience, allowing them to achieve comparable or superior performance with less exertion per play.

![](photos/EffMetricsChart.png){width=80%}

The two metrics are positively correlated, as expected given their similar derivation. Both were ultimately designed to capture the same underlying concept: how a RB’s observed acceleration compares to their individual maximum acceleration frontier. 

### Validation Model

![](photos/Rf_preds.png){width=80%}

Our expected EPA model yielded a root mean squared error (RMSE) of 0.929. Given that EPA values typically range from -10 to +6, this level of error is acceptable. However, the random forest model demonstrates limited accuracy on plays with extreme EPA values. It is plausible to initially speculate that this underperformance stems from the model’s omission of effort as a predictor, impairing its ability to fully explain EPA variation.

The correlations between model residuals and each effort metric were near zero, indicating that the model’s prediction errors are likely not due to the absence of effort-based features, contrary to our initial hypothesis. This suggests that effort—as defined by proximity to the maximum acceleration frontier–does not reliably predict deviations from expected play value, and thus may not necessarily translate to better on-field performance.  

![](photos/EffortCorrelations.png){width=80%}

Further analysis confirms this result: both effort metrics show negligible correlation with several play outcome variables. Taken together, these findings corroborate that effort, by our definition, does not directly contribute to superior results. 


## Discussion

A-S-based effort, while measurable and player-specific, is insufficient on its own to explain RB performance. A player’s ability to consistently reach or exceed their individual maximum acceleration frontier might indicate physical exertion, intent, or athletic capacity, but it does not directly correspond to play outcomes such as rushing yards and EPA. This implies that effort, as captured by our metrics, reflects only one dimension of performance—namely, the intensity of a player’s movement—while omitting cognitive, tactical, and contextual influences that likely play an equal or greater role in shaping on-field outcomes. As such, A-S-based effort should be interpreted as a complementary metric rather than a standalone indicator of performance or effectiveness.  

Quantifying effort remains a complex task with no single definitive solution. Nonetheless, isolating and measuring its physical component provides a concrete foundation for developing more comprehensive metrics in the future. 

### Limitations
A key limitation of our effort metrics is their inability to fully account for player and game context. For instance, if a RB decelerates sharply due to a tackle, the model interprets this deceleration as effortful—despite it being the result of external contact rather than intentional exertion. By omitting physical interactions or play-specific dynamics, the metrics risk misclassifying non-effortful outcomes. A more robust alternative might involve modeling expected acceleration based on situational variables and using these predictions—rather than observed values—in the A-S profile to better capture true exertion.

Another shortcoming arises from the individualized nature of each player’s A-S profile. While this approach accounts for physical differences between players, it holds each to a different standard. For example, athletically gifted players, such as Saquon Barkley, generate higher 0.95 quantile acceleration curves, thereby requiring greater exertion to meet the same relative effort threshold. In other words, the same level of physical output may be classified differently depending on the athlete’s profile, complicating comparisons across players.

Finally, our use of EPA over expected as a validation method may not fully isolate the RB’s individual contribution. Since EPA is influenced by various external and team-level factors outside of the RB’s direct control (e.g., offensive efficiency, blocking, play calling), it does not exclusively reflect the impact of a single player’s effort. Consequently, high EPA plays might be driven more by team execution than personal exertion. Validating against metrics more directly attributable to RB-specific action may offer a clearer assessment of our approach. 

### Future Work
A natural extension of this study is applying the effort metrics to wide receivers. One area of interest is how a receiver's effort differs when they anticipate being targeted versus when they do not. By examining how often a receiver approaches or exceeds their maximum acceleration frontier in each scenario, we can evaluate whether effort remains consistent regardless of play assignment.

Another direction involves refining our definition of effort to more accurately reflect its relationship with performance. While our current metrics measure how often a RB attains near-maximal acceleration, they do not directly account for whether this effort translates into successful play outcomes. Given the subjective and context-dependent nature of effort, future research may involve integrating additional situational or performance-based variables to better link exertion with effectiveness. 


## Acknowledgements
Many thanks to Sam Ventura from the Buffalo Sabres for his guidance and mentorship throughout the project. We are grateful for the time and dedication Sam has put into this work.
We also want to thank Quang Nguyen for his instruction, advice, and support throughout the summer research experience. Quang had provided us with the resources necessary to get started with the NFL Big Data Bowl tracking data. Finally, we would like to thank Dr. Ron Yurko and the CMSAC teaching staff for sharing with us their knowledge and inspiring ideas. 


## References
<div style="text-indent: -1.7em; padding-left: 1.7em; margin-bottom: 1em;">
[1] Morin, J., Mat, Y. L., Osgnach, C., Barnabò, A., Pilati, A., Samozino, P., & Di Prampero, P. E. (2021). Individual acceleration-speed profile in-situ: A proof of concept in professional football players. Journal of Biomechanics, 123, 110524. https://doi.org/10.1016/j.jbiomech.2021.110524
</div>

<div style="text-indent: -1.7em; padding-left: 1.7em; margin-bottom: 1em;">
[2] Michael Lopez, Thompson Bliss, Ally Blake, Paul Mooney, and Addison Howard. NFL Big Data Bowl 2025. https://kaggle.com/competitions/nfl-big-data-bowl-2025, 2024. Kaggle.
</div>

<div style="text-indent: -1.7em; padding-left: 1.7em; margin-bottom: 1em;">
[3] Hader, K., Mendez-Villanueva, A., Palazzi, D., Ahmaidi, S., & Buchheit, M. (2016). Metabolic Power Requirement of Change of Direction Speed in Young Soccer Players: Not All Is What It Seems. PloS one, 11(3), e0149839. https://doi.org/10.1371/journal.pone.0149839
</div>


```{r, fig.width=17, fig.height= 7}
#| label: combined
#| fig-cap: "....."
#| message: false
#| warning: false
#| cache: true

load("web_data/tracking_bc2.Rdata")
load("web_data/player_runs_modeling.Rdata")

# Generate the two ggplots
plot_saquon <- eff_function_nlrq("Saquon Barkley", graph = TRUE)
plot_cook <- eff_function_nlrq("James Cook", graph = TRUE)

# Combine side by side with shared legend
(plot_saquon + plot_cook) +
  plot_layout(guides = "collect") &
  theme(legend.position = "right")



```





### plotly

```{r, fig.width= 10, fig.height = 10}
#| label: plot-ly
#| message: false
#| warning: false
#| cache: true


load("web_data/tracking_bc2.Rdata")
load("web_data/player_runs_modeling.Rdata")

eff_function_nlrq_plotly <- function(name, graph = FALSE) {
  player_runs <- tracking_bc |> 
    filter(displayName == name)

  player_runs_modeling <- player_runs |> 
    select(s_mph, dir_a_mpsh, gameId, displayName, bc_id, playId, frameId)

  data_pos <- player_runs_modeling |> filter(dir_a_mpsh >= 0)
  data_neg <- player_runs_modeling |> filter(dir_a_mpsh < 0)

  nlrq_pos <- nlrq(dir_a_mpsh ~ x * s_mph^2 + y * s_mph + z,
                   data = data_pos,
                   tau = .95,
                   start = list(x = 10, y = 2, z = 5))
  
  nlrq_neg <- nlrq(dir_a_mpsh ~ x * s_mph^2 + y * s_mph + z,
                   data = data_neg,
                   tau = .05,
                   start = list(x = 10, y = 2, z = 5))

  data_pos_final <- data_pos |> 
    mutate(nlrq_pred = nlrq_pos$m$fitted(),
           diff_a = nlrq_pred - dir_a_mpsh)

  data_neg_final <- data_neg |> 
    mutate(nlrq_pred = nlrq_neg$m$fitted(),
           diff_a = dir_a_mpsh - nlrq_pred)

  player_runs_test_preds <- rbind(data_pos_final, data_neg_final)

  if (graph == TRUE) {
    out_line <- player_runs_test_preds |> filter(diff_a <= 0)

    # Build ggplot with text column for tooltips
    p <- ggplot(player_runs_test_preds, aes(x = s_mph, y = dir_a_mpsh)) +
      geom_point(aes(text = paste0("Speed: ", round(s_mph, 2),
                                   "<br>Acceleration: ", round(dir_a_mpsh, 2))),
                 alpha = 0.6, color = "grey2", show.legend = FALSE) +
      geom_point(data = out_line, aes(
        text = paste0("Speed: ", round(s_mph, 2),
                      "<br>Acceleration: ", round(dir_a_mpsh, 2))),
        size = 4, stroke = 1.2, color = "black", shape = 21, fill = "#b3b3b3") +
      geom_line(data = data_pos_final, aes(y = nlrq_pred, color = "0.95 quantile accel. \nregression line"), lwd = 1.2) +
      geom_line(data = data_neg_final, aes(y = nlrq_pred, color = "0.95 quantile decel. \nregression line"), lwd = 1.2) +
      geom_hline(aes(yintercept = 0), color = "black", lwd = 1.2, lty = 2) +
      scale_color_manual("Line", values = c("#D55E00", "#0072B2", "goldenrod")) +
      labs(x = "Speed (mph)",
           y = "Acceleration (mph/s)",
           title = paste0(name, "'s effort score: 18.65%")) +
      theme_minimal(base_size=16) +
      theme(plot.title = element_text(face = "bold.italic", size = 18, hjust = .5),
            legend.title = element_text(face = "bold"),
            axis.title = element_text(face = "bold"),
            legend.text=element_text(size=15),
            plot.caption = element_text(face = "italic", size = 8),
            legend.key.height = unit(1.4, "cm"),
            legend.position = "right") +
      xlim(0, 25) +
      ylim(-15, 15)

    return(ggplotly(p, tooltip = "text"))
  }

  return(player_runs_test_preds)
}

# testing player
#eff_function_nlrq_plotly("Saquon Barkley", graph = TRUE)


```


```{r}
#| label: first-metric-drop
#| fig-cap: "testing out a few players"
#| message: false
#| warning: false
#| cache: true

# Player list (in progress)
# rb_menu <- c("Saquon Barkley", "Rex Burkhead", "D'Andre Swift", 
#                 "Samaje Perine", "Joshua Kelley", "Matt Breida", "Alexander Mattison")
# 
# # Initialize plot
# fig6 <- plot_ly()
# all_traces <- list()
# visibility_masks <- list()
# trace_lengths <- c()
# 
# #Loop through each running back to collect their traces
# for (i in seq_along(rb_menu)) {
#   player <- rb_menu[i]
#   plot_obj <- ggplotly(eff_function_qgam(player, graph = TRUE))
#   
#   player_traces <- list()
#   for (trace in plot_obj$x$data) {
#     if (trace$mode == "markers") {
#     }
#     trace$visible <- (i == 1) 
#     
#     # this is to display the first running back's AS quantile regression 
#     fig6 <- fig6 |> add_trace(
#       x = trace$x,
#       y = trace$y,
#       type = trace$type,
#       mode = trace$mode,
#       line = trace$line,
#       marker = if (!is.null(trace$marker$color)) trace$marker else NULL,
#       name = trace$name,
#       text = trace$text,
#       hoverinfo = trace$hoverinfo,
#       visible = trace$visible
#     )
#     player_traces <- append(player_traces, list(trace))
#   }
#   
#   all_traces[[i]] <- player_traces
#   trace_lengths[i] <- length(player_traces)
# }
# 
# #  Visibility masks for dropdown
# total_traces <- sum(trace_lengths)
# 
# for (i in seq_along(rb_menu)) {
#   mask <- rep(FALSE, total_traces)
#   start_index <- sum(trace_lengths[1:(i - 1)]) + 1
#   end_index <- sum(trace_lengths[1:i])
#   mask[start_index:end_index] <- TRUE
#   visibility_masks[[i]] <- mask
# }
# 
# # Adding dropdown menu
# dropdown_buttons <- lapply(seq_along(rb_menu), function(i) {
#   list(
#     method = "update",  # update both trace visibility and layout
#     args = list(
#       list(visible = visibility_masks[[i]]),  # traces to show
#       list(title = list(text = paste0(rb_menu[i], "'s Effort Quantile (95%)")))  # title change
#     ),
#     label = rb_menu[i]
#   )
# })
# 
# fig6 <- fig6 |>
#   layout(
#     title = list(text = paste0(rb_menu[1], "'s Effort Quantile (95%)")), 
#     yaxis = list(title = "Acceleration (mph/s)"),
#     xaxis = list(title = "Speed (mph)"),
#     updatemenus = list(
#       list(
#         type = "dropdown",
#         y = 0.8,
#         x = 1.1,
#         buttons = dropdown_buttons
#       )
#     )
#   )
# fig6

```




```{r}
##| label: percentile-lines-regression
##| fig-cap: "Percentage of total points that lie in between the percentile $P_{99}$ and $P_{99}-3$"

# NOTE: takes a bit to run since the function is iterating through a lot of players! >:(

#================ [Interactive drop down menu to select any running backs (syntax)]================#

# eff_function_qgam <- function(name, graph = FALSE) {
#   # Filter player runs
#   player_runs <- tracking_bc |> 
#     filter(displayName == name)
#   
#   # Define folds
#   N_FOLDS <- 5
#   
#   # Assign folds by game
#   plays_folds <- player_runs |> 
#     distinct(gameId) |> 
#     mutate(fold = sample(rep(1:N_FOLDS, length.out = n())))
#   
#   # Merge with folds and select modeling variables
#   player_runs_modeling <- player_runs |> 
#     select(s_mph, a_mpsh, gameId) |> 
#     left_join(plays_folds, by = "gameId") |> 
#     select(-gameId)
# 
#   # Cross-validation logic
#   player_runs_cv <- function(x) {
#     test_data <- player_runs_modeling |> filter(fold == x)
#     train_data <- player_runs_modeling |> filter(fold != x)
#     
# # trying to suppress messages from qgam() model in the final rendered file
#     
#     suppressMessages({
#   suppressWarnings({
#     capture.output({
#       qgam_fit <- qgam(
#         a_mpsh ~ s(s_mph, k = 15, bs = "ad"),
#         data = train_data,
#         qu = .99,
#         multicore = TRUE,
#         ncores = 7
#       )
#     })
#   })
# })
# 
#     tibble(
#       displayName = name,
#       qgam_pred = predict(qgam_fit, newdata = test_data),
#       actual_acc = test_data$a_mpsh,
#       actual_speed = test_data$s_mph,
#       res = test_data$a_mpsh - predict(qgam_fit, newdata = test_data),
#       qgam_pred_minus_3 = predict(qgam_fit, newdata = test_data) - 3,
#       test_fold = x
#     )
#   }
# 
#   # Run CV and collect predictions
#   player_runs_test_preds <- map(1:N_FOLDS, player_runs_cv) |> 
#     bind_rows()
# 
#   # Compute effort score (proportion below the 99th percentile line)
#   eff_score <- mean(player_runs_test_preds$res < 0)
# 
#   if (graph == TRUE) {
#     # Fit final GAM lines for plotting
#     gam_fit_99 <- mgcv::gam(qgam_pred ~ s(actual_speed, k = 15, bs = "ad"), data = player_runs_test_preds)
# gam_fit_99m3 <- mgcv::gam(qgam_pred_minus_3 ~ s(actual_speed, k = 15, bs = "ad"), data = player_runs_test_preds)
# 
#     s_seq <- seq(min(player_runs_test_preds$actual_speed, na.rm = TRUE),
#                  max(player_runs_test_preds$actual_speed, na.rm = TRUE),
#                  length.out = 200)
#     pred_df <- tibble(
#       s = s_seq,
#       pred_99 = predict(gam_fit_99, newdata = tibble(actual_speed = s_seq)),
#       pred_99m3 = predict(gam_fit_99m3, newdata = tibble(actual_speed = s_seq))
#     )
# 
#     # ggplot
#     p <- ggplot() +
#       geom_point(data = player_runs_test_preds %>% mutate(color = "grey2"), aes(
#         x = actual_speed, 
#         y = actual_acc,
#         color = color,
#         text = paste0("Speed: ", round(actual_speed, 2),
#                       "<br>Acceleration: ", round(actual_acc, 2))), 
#       alpha = 0.55, 
#       # so the data point's color doesn't show on the legend
#       show.legend = FALSE) + 
#       geom_line(data = pred_df, aes(x = s, y = pred_99, color = "99th percentile"), size = 1.2) +
#       geom_line(data = pred_df, aes(x = s, y = pred_99m3, color = "99th percentile - 3"), linetype = "dashed", size = 1.2) +
#       scale_color_manual(values = c("99th percentile" = "#0072B2", "99th percentile - 3" = "black")) +
#       labs(
#         title = paste0(name, "'s Effort Quantile Curve (99%)"),
#         x = "Speed (mph)",
#         y = "Acceleration (m/s²)",
#         caption = "Data from Weeks 1–9 of the 2022 NFL Season"
#       ) +
#       theme_minimal(base_size = 16) +
#       theme(
#         plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
#         axis.title = element_text(face = "bold", size = 14),
#         axis.text = element_text(size = 12),
#         legend.title = element_text(face = "bold"),
#         legend.text = element_text(size = 13),
#         plot.caption = element_text(face = "italic", size = 10)
#       )
# 
#     return(ggplotly(p, tooltip = "text"))
#   }
# 
#   return(tibble(displayName = name, effort_ratio_99 = 1 - eff_score))
# }
```


```{r}
#| label: top-players
#| fig-cap: "Top 10"
#| message: false
#| warning: false
#| cache: true

# Player list
rb_dd_list <- c("Chase Edmonds", "Rachaad White", "D'Andre Swift", 
                "Samaje Perine", "Joshua Kelley", "Matt Breida", "Alexander Mattison",
                "Josh Jacobs", "James Cook", "Melvin Gordon")

# Initialize plot
fig2 <- plot_ly()
all_traces <- list()
visibility_masks <- list()
trace_lengths <- c()

#Loop through each running back to collect their traces
for (i in seq_along(rb_dd_list)) {
  player <- rb_dd_list[i]
  plot_obj <- ggplotly(eff_function_qgam(player, graph = TRUE))
  
  player_traces <- list()
  for (trace in plot_obj$x$data) {
    if (trace$mode == "markers") {
    }
    trace$visible <- (i == 1) 
    
    # this is to display the first running back's AS quantile regression 
    fig2 <- fig2 |> add_trace(
      x = trace$x,
      y = trace$y,
      type = trace$type,
      mode = trace$mode,
      line = trace$line,
      marker = if (!is.null(trace$marker$color)) trace$marker else NULL,
      name = trace$name,
      text = trace$text,
      hoverinfo = trace$hoverinfo,
      visible = trace$visible
    )
    player_traces <- append(player_traces, list(trace))
  }
  
  all_traces[[i]] <- player_traces
  trace_lengths[i] <- length(player_traces)
}

#  Visibility masks for dropdown
total_traces <- sum(trace_lengths)

for (i in seq_along(rb_dd_list)) {
  mask <- rep(FALSE, total_traces)
  start_index <- sum(trace_lengths[1:(i - 1)]) + 1
  end_index <- sum(trace_lengths[1:i])
  mask[start_index:end_index] <- TRUE
  visibility_masks[[i]] <- mask
}

# Adding dropdown menu
dropdown_buttons <- lapply(seq_along(rb_dd_list), function(i) {
  list(method = "restyle",
       args = list("visible", visibility_masks[[i]]),
       label = rb_dd_list[i])
})

fig2 <- fig2 |>
  layout(
    title = "Running Backs' Effort Quantile Curve (99%)",
    yaxis = list(title = "acceleration"),
    xaxis = list(title = "Speed"),
    updatemenus = list(
      list(
        type = "dropdown",
        y = 0.8,
        x = 1.1,
        buttons = dropdown_buttons
      )
    )
  )
fig2


```



```{r}
#| label: linear-regression
#| fig-cap: "Linear quantile regression for acceleration(mph/s) vs speed(mph)"

load("web_data/tracking_bc.Rdata")
load("web_data/player_runs_modeling.Rdata")

eff_function <- function(name, graph = FALSE, player_table = FALSE) {
  # Filter data for selected player
  player_runs <- tracking_bc |> 
    filter(displayName == name)
  
  # Speed bins
  bins <- seq(3, round(max(player_runs$s_mph), 2) + .2, .2)

  # Select top-2 acceleration points per bin
  max_acc <- map_dfr(1:(length(bins) - 1), function(i) {
    player_runs |> 
      filter(s_mph > bins[i], s_mph <= bins[i + 1]) |> 
      slice_max(a_mpsh, n = 2, with_ties = FALSE) |> 
      select(speed = s_mph, acceleration = a_mpsh)
  })
  
  # Fit linear model
  player_lm <- lm(acceleration ~ speed, data = max_acc)
  confs <- predict(player_lm, interval = "confidence")
  max_acc <- bind_cols(max_acc, confs)
  
  # Filter outliers outside 95% CI
  max_acc_clean <- max_acc |> 
    filter(acceleration >= lwr, acceleration <= upr)
  
  # Refit linear model
  player_lm_clean <- lm(acceleration ~ speed, data = max_acc_clean)
  
  # Predicted values and difference from fitted line
  test_player_a <- tibble(speed = player_runs$s_mph, acceleration = player_runs$a_mpsh)
  test_preds <- predict(player_lm_clean, newdata = test_player_a)
  
  player_final <- player_runs |> 
    select(a_mpsh, s_mph) |> 
    mutate(pred = test_preds,
           diff = pred - a_mpsh,
           eff = diff <= 0.25,
           eff_50 = diff <= 0.5,
           eff_75 = diff <= 0.75,
           gameId = player_runs$gameId,
           playId = player_runs$playId,
           bc_id = player_runs$bc_id,
           displayName = player_runs$displayName,
           frameId = player_runs$frameId)
  
  # Summary effort score
  eff <- tibble(
    eff_metric = sum(player_final$eff, na.rm = TRUE),
    eff_metric_perc = sum(player_final$eff, na.rm = TRUE) / nrow(player_final) * 100,
    eff_metric_50 = sum(player_final$eff_50, na.rm = TRUE),
    eff_metric_perc_50 = sum(player_final$eff_50, na.rm = TRUE) / nrow(player_final) * 100,
    eff_metric_75 = sum(player_final$eff_75, na.rm = TRUE),
    eff_metric_perc_75 = sum(player_final$eff_75, na.rm = TRUE) / nrow(player_final) * 100
  )
  
  if (graph == TRUE) {
    # Build regression lines
    intercept <- player_lm_clean$coefficients[1]
    slope <- player_lm_clean$coefficients[2]
    s_seq <- seq(min(player_runs$s_mph), max(player_runs$s_mph), length.out = 200)
    
    reg_df <- tibble(
      speed = s_seq,
      reg = intercept + slope * s_seq,
      reg_minus_025 = intercept - 0.25 + slope * s_seq
    )
    
    # Plotly plot
    p <- ggplot(player_final, aes(x = s_mph, y = a_mpsh)) +
      geom_point(aes(text = paste0("Speed: ", round(s_mph, 2), "<br>Accel: ", round(a_mpsh, 2))), 
                 color = "grey20", alpha = 0.55) +
      geom_line(data = reg_df, aes(x = speed, y = reg, color = "Regression line"), size = 1.2) +
      geom_line(data = reg_df, aes(x = speed, y = reg_minus_025, color = "Regression line - 0.25"), 
                linetype = "dashed", size = 1.2) +
      scale_color_manual("Line", values = c("Regression line" = "#0072B2", 
                                            "Regression line - 0.25" = "#D55E00")) +
      labs(
        title = paste0(name, "'s Effort: ", round(eff$eff_metric_perc, 2), "%"),
        x = "Speed (mph)",
        y = "Acceleration (m/s²)",
        caption = "Effort defined as within 0.25 m/s² of fitted top acceleration"
      ) +
      theme_minimal(base_size = 16) +
      theme(
        plot.title = element_text(face = "bold", hjust = 0.5, size = 18),
        axis.title = element_text(face = "bold", size = 14),
        axis.text = element_text(size = 12),
        legend.title = element_text(face = "bold"),
        legend.text = element_text(size = 13),
        plot.caption = element_text(face = "italic", size = 10)
      )

    return(ggplotly(p, tooltip = "text"))
  }
  
  if (player_table == TRUE) {
    return(player_final)
  }

  return(eff)
}

# testing one player
eff_function("Saquon Barkley", graph = TRUE)


#===================[ making interactive drop down menu ]=======================

# rb_dd_list <- c("Saquon Barkley", "Rex Burkhead", "Chase Edmonds", "Rachaad White", "D'Andre Swift", 
#                 "Samaje Perine", "Joshua Kelley", "Matt Breida", "Alexander Mattison",
#                 "Josh Jacobs", "James Cook", "Melvin Gordon")
# 
# # Initialize plot
# fig2 <- plot_ly()
# all_traces <- list()
# visibility_masks <- list()
# trace_lengths <- c()
# 
# #Loop through each running back to collect their traces
# for (i in seq_along(rb_dd_list)) {
#   player <- rb_dd_list[i]
#   plot_obj <- ggplotly(eff_function_qgam(player, graph = TRUE))
#   
#   player_traces <- list()
#   for (trace in plot_obj$x$data) {
#     trace$visible <- (i == 1) 
#     
#     # this is to display the first running back's AS quantile regression 
#     fig2 <- fig2 |> add_trace(
#       x = trace$x,
#       y = trace$y,
#       type = trace$type,
#       mode = trace$mode,
#       line = trace$line,
#       name = trace$name,
#       text = trace$text,
#       hoverinfo = trace$hoverinfo,
#       visible = trace$visible
#     )
#     player_traces <- append(player_traces, list(trace))
#   }
#   
#   all_traces[[i]] <- player_traces
#   trace_lengths[i] <- length(player_traces)
# }
# 
# #  Visibility masks for dropdown
# total_traces <- sum(trace_lengths)
# 
# for (i in seq_along(rb_dd_list)) {
#   mask <- rep(FALSE, total_traces)
#   start_index <- sum(trace_lengths[1:(i - 1)]) + 1
#   end_index <- sum(trace_lengths[1:i])
#   mask[start_index:end_index] <- TRUE
#   visibility_masks[[i]] <- mask
# }
# 
# # Adding dropdown menu
# dropdown_buttons <- lapply(seq_along(rb_dd_list), function(i) {
#   list(method = "restyle",
#        args = list("visible", visibility_masks[[i]]),
#        label = rb_dd_list[i])
# })
# 
# fig2 <- fig2 |>
#   layout(
#     title = "Acceleration vs Speed Individualized Profile by Running Back",
#     updatemenus = list(
#       list(
#         type = "dropdown",
#         y = 0.8,
#         x = 1.1,
#         buttons = dropdown_buttons
#       )
#     )
#   )
# fig2


```



```{r}
#| label: results-scatterplot
#| fig-cap: "correlation between metric #1 and metric #2"
#| message: false
#| warning: false
#| cache: true

## Scatterplot
dis_scatter <- qgam_dis_player |> 
  mutate(dis_score_qgam = dis_score,
         rank_qgam = rank) |> 
  select(-dis_score, -rank) |> 
  left_join(nlrq_dis_player, by = c("bc_id", "displayName"))

label_names <- dis_scatter |> 
  filter(rank_qgam <= 6 | rank <= 6 | rank_qgam >=64 
         | rank >= 64 | displayName %in% c("Saquon Barkley", "James Cook"))

dis_scatter |> 
  ggplot(aes(x = dis_score, y = dis_score_qgam)) +
  geom_hline(aes(yintercept = mean(dis_score_qgam)), lwd = 1.2, lty = 2, color = "#D50A0A") +
  geom_vline(aes(xintercept = mean(dis_score)), lwd = 1.2, lty = 2, color = "#D50A0A") +
  geom_point(aes(color = dis_score), size = 3, alpha = .8) +
  scale_color_gradient(low = "#0072B2", high = "#D55E00") +
  labs(title = "Player effort metrics positively correlate with each other",
       x = "Effort metric #1 (non-linear quantile regression)",
       y = "Effort metric #2 (GAM quantile regression)")+
  theme_minimal(base_size=16) +
  theme(plot.title = element_text(face = "bold.italic",
                                  size = 18, 
                                  hjust = .5),
        legend.position = "none",
        axis.title = element_text(face = "bold")) +
  ggrepel::geom_text_repel(data = label_names, aes(label = displayName), 
                           size = 5, max.overlaps = 15,
                           fontface = "italic")
  
```



## Trying a different interactive layout

::: {.panel-tabset}

### Tab 1: Saquon Barkley
```{r}
##| label: fig-quant-1
##| fig-cap: "trying non-linear-quant-regression"

# load("web_data/tracking_bc.Rdata")
# load("web_data/player_runs_modeling.Rdata")
# 
# 
# set.seed(1)
# 
# eff_function_rqss <- function(name, graph = FALSE) {
#   player_runs <- tracking_bc |> 
#     filter(displayName == name)
# 
#   N_FOLDS <- 5
#   player_runs_modeling <- player_runs |> 
#     select(s, a) |> 
#     mutate(fold = sample(rep(1:N_FOLDS, length.out = n())))
#   
#   player_runs_cv <- function(x) {
#     test_data <- player_runs_modeling |> 
#       filter(fold == x)
#     train_data <- player_runs_modeling |> 
#       filter(fold != x)
#     
#     s_range <- range(train_data$s)
#     test_data <- test_data |> 
#       filter(s >= max(s_range[1], 1),
#              s <= min(s_range[2], 9))
#     
#     rq_fit <- rqss(a ~ qss(s, lambda = 3), tau = 0.9, data = train_data)
#     
#     out <- tibble(
#       rq_pred = predict(rq_fit, newdata = test_data),
#       test_actual = test_data$a,
#       res_rq = test_actual - rq_pred,
#       test_fold = x
#     )
#     return(out)
#   }
# 
#   player_runs_test_preds <- map(1:N_FOLDS, player_runs_cv) |> 
#     list_rbind()
#   
#   eff_score <- mean(player_runs_test_preds$res_rq < 0)
# 
#   if (graph == TRUE) {
#     # Fit final model and compute smooth prediction line
#     rq_fit <- rqss(a ~ qss(s, lambda = 3), tau = 0.9, data = player_runs)
#     s_seq <- seq(min(player_runs$s, na.rm = TRUE), max(player_runs$s, na.rm = TRUE), length.out = 100)
#     pred_df <- tibble(s = s_seq)
#     pred_df$a <- predict(rq_fit, newdata = pred_df)
# 
#     # Interactive ggplot
#     p <- ggplot() +
#       geom_point(data = player_runs, aes(
#       x = s, 
#       y = a,
#       text = paste0("Speed: ", round(s, 2),
#                     "<br>Acceleration: ", round(a, 2))), 
#       alpha = 0.5, 
#       color = "grey40") +
#       geom_line(data = pred_df, aes(x = s, y = a), 
#                 color = "blue", size = 1.2) +
#       scale_x_continuous(name = "Speed") +
#       scale_y_continuous(name = "Acceleration") +
#       labs(
#         title = paste0(name, "'s Effort Quantile Curve (90%)"),
#         caption = "Data from Weeks 1–9 of the 2022 NFL Season"
#       ) +
#       theme_minimal() +
#       theme(
#         plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
#         axis.title = element_text(face = "bold", size = 14),
#         axis.text = element_text(size = 12),
#         plot.caption = element_text(face = "italic", size = 9)
#       )
# 
#     return(ggplotly(p, tooltip = "text"))
#   }
# 
#   return(tibble(displayName = name, effort_ratio_90 = 1 - eff_score))
# }
# 
# 
#  (eff_function_rqss("Saquon Barkley", graph = TRUE))

```


### Tab 2: Rex Burkhead
```{r}
##| label: fig-quant-2
##| fig-cap: "trying out non-linear-quant-regression"

# 
# 
# set.seed(1)
# 
# eff_function_rqss <- function(name, graph = FALSE) {
#   player_runs <- tracking_bc |> 
#     filter(displayName == name)
# 
#   N_FOLDS <- 5
#   player_runs_modeling <- player_runs |> 
#     select(s, a) |> 
#     mutate(fold = sample(rep(1:N_FOLDS, length.out = n())))
#   
#   player_runs_cv <- function(x) {
#     test_data <- player_runs_modeling |> 
#       filter(fold == x)
#     train_data <- player_runs_modeling |> 
#       filter(fold != x)
#     
#     s_range <- range(train_data$s)
#     test_data <- test_data |> 
#       filter(s >= max(s_range[1], 1),
#              s <= min(s_range[2], 9))
#     
#     rq_fit <- rqss(a ~ qss(s, lambda = 3), tau = 0.9, data = train_data)
#     
#     out <- tibble(
#       rq_pred = predict(rq_fit, newdata = test_data),
#       test_actual = test_data$a,
#       res_rq = test_actual - rq_pred,
#       test_fold = x
#     )
#     return(out)
#   }
# 
#   player_runs_test_preds <- map(1:N_FOLDS, player_runs_cv) |> 
#     list_rbind()
#   
#   eff_score <- mean(player_runs_test_preds$res_rq < 0)
# 
#   if (graph == TRUE) {
#     # Fit final model and compute smooth prediction line
#     rq_fit <- rqss(a ~ qss(s, lambda = 3), tau = 0.9, data = player_runs)
#     s_seq <- seq(min(player_runs$s, na.rm = TRUE), max(player_runs$s, na.rm = TRUE), length.out = 100)
#     pred_df <- tibble(s = s_seq)
#     pred_df$a <- predict(rq_fit, newdata = pred_df)
# 
#     # Interactive ggplot
#     p <- ggplot() +
#       geom_point(data = player_runs, aes(
#       x = s, 
#       y = a,
#       text = paste0("Speed: ", round(s, 2),
#                     "<br>Acceleration: ", round(a, 2))), 
#       alpha = 0.5, 
#       color = "grey40") +
#       geom_line(data = pred_df, aes(x = s, y = a), 
#                 color = "blue", size = 1.2) +
#       scale_x_continuous(name = "Speed") +
#       scale_y_continuous(name = "Acceleration") +
#       labs(
#         title = paste0(name, "'s Effort Quantile Curve (90%)"),
#         caption = "Data from Weeks 1–9 of the 2022 NFL Season"
#       ) +
#       theme_minimal() +
#       theme(
#         plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
#         axis.title = element_text(face = "bold", size = 14),
#         axis.text = element_text(size = 12),
#         plot.caption = element_text(face = "italic", size = 9)
#       )
# 
#     return(ggplotly(p, tooltip = "text"))
#   }
# 
#   return(tibble(displayName = name, effort_ratio_90 = 1 - eff_score))
# }
# 
# 
#  (eff_function_rqss("Rex Burkhead", graph = TRUE))

```
:::






